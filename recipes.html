

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Recipes &mdash; mbuild 0.8.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Citing mBuild" href="citing_mbuild.html" />
    <link rel="prev" title="Coordinate transformations" href="coordinate_transforms.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> mbuild
          

          
          </a>

          
            
            
              <div class="version">
                0.8.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorials/tutorials.html">Tutorials</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="data_structures.html">Data Structure</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="coordinate_transforms.html">Coordinate transformations</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Recipes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#monolayer">Monolayer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#polymer">Polymer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tiled-compound">Tiled Compound</a></li>
<li class="toctree-l2"><a class="reference internal" href="#silica-interface">Silica Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lattice">Lattice</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-mbuild.packing">Packing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-mbuild.pattern">Pattern</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="citing_mbuild.html">Citing mBuild</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">mbuild</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Recipes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/recipes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="recipes">
<h1>Recipes<a class="headerlink" href="#recipes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="monolayer">
<h2>Monolayer<a class="headerlink" href="#monolayer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="mbuild.recipes.monolayer.Monolayer">
<em class="property">class </em><code class="descclassname">mbuild.recipes.monolayer.</code><code class="descname">Monolayer</code><span class="sig-paren">(</span><em>surface</em>, <em>chains</em>, <em>fractions=None</em>, <em>backfill=None</em>, <em>pattern=None</em>, <em>tile_x=1</em>, <em>tile_y=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mbuild/recipes/monolayer.html#Monolayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer" title="Permalink to this definition">¶</a></dt>
<dd><p>A general monolayer recipe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>surface</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd><p class="first last">Surface on which the monolayer will be built.</p>
</dd>
<dt><strong>chains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of mb.Compounds</span></dt>
<dd><p class="first last">The chains to be replicated and attached to the surface.</p>
</dd>
<dt><strong>fractions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of floats</span></dt>
<dd><p class="first last">The fractions of the pattern to be allocated to each chain.</p>
</dd>
<dt><strong>backfill</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of mb.Compound, optional, default=None</span></dt>
<dd><p class="first last">If there are fewer chains than there are ports on the surface,
copies of <cite>backfill</cite> will be used to fill the remaining ports.</p>
</dd>
<dt><strong>pattern</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Pattern, optional, default=mb.Random2DPattern</span></dt>
<dd><p class="first last">An array of planar binding locations. If not provided, the entire
surface will be filled with <cite>chain</cite>.</p>
</dd>
<dt><strong>tile_x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1</span></dt>
<dd><p class="first last">Number of times to replicate substrate in x-direction.</p>
</dd>
<dt><strong>tile_y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1</span></dt>
<dd><p class="first last">Number of times to replicate substrate in y-direction.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>new_child</em>, <em>label=None</em>, <em>containment=True</em>, <em>replace=False</em>, <em>inherit_periodicity=True</em>, <em>reset_rigid_ids=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a part to the Compound.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>This does not necessarily add the part to self.children but may
instead be used to add a reference to the part to self.labels. See
‘containment’ argument.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_child</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list-like of mb.Compound</span></dt>
<dd><p class="first last">The object(s) to be added to this Compound.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">A descriptive string for the part.</p>
</dd>
<dt><strong>containment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Add the part to self.children.</p>
</dd>
<dt><strong>replace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Replace the label if it already exists.</p>
</dd>
<dt><strong>inherit_periodicity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Replace the periodicity of self with the periodicity of the
Compound being added</p>
</dd>
<dt><strong>reset_rigid_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">If the Compound to be added contains rigid bodies, reset the
rigid_ids such that values remain distinct from rigid_ids
already present in <cite>self</cite>. Can be set to False if attempting
to add Compounds to an existing rigid body.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.add_bond">
<code class="descname">add_bond</code><span class="sig-paren">(</span><em>particle_pair</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.add_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a bond between two Particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>particle_pair</strong> <span class="classifier-delimiter">:</span> <span class="classifier">indexable object, length=2, dtype=mb.Compound</span></dt>
<dd><p class="first last">The pair of Particles to add a bond between</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.all_ports">
<code class="descname">all_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.all_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Ports referenced by this Compound and its successors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all Ports referenced by this Compound and its successors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.ancestors">
<code class="descname">ancestors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.ancestors" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all ancestors of the Compound recursively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Compound above self in the hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.available_ports">
<code class="descname">available_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.available_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all unoccupied Ports referenced by this Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all unoccupied ports referenced by the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.bonds">
<code class="descname">bonds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all bonds in the Compound and sub-Compounds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple of mb.Compound</strong></dt>
<dd><p class="first last">The next bond in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bond_graph.edges_iter</span></code></dt>
<dd>Iterates over all edges in a BondGraph</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.monolayer.Monolayer.boundingbox">
<code class="descname">boundingbox</code><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.boundingbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bounding box of the compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Box</strong></dt>
<dd><p class="first last">The bounding box for this Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.monolayer.Monolayer.center">
<code class="descname">center</code><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.center" title="Permalink to this definition">¶</a></dt>
<dd><p>The cartesian center of the Compound based on its Particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>np.ndarray, shape=(3,), dtype=float</strong></dt>
<dd><p class="first last">The cartesian center of the Compound based on its Particles</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.monolayer.Monolayer.contains_rigid">
<code class="descname">contains_rigid</code><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.contains_rigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the Compound contains rigid bodies</p>
<p>If the Compound contains any particle with a rigid_id != None
then contains_rigid will return True. If the Compound has no
children (i.e. the Compound resides at the bottom of the containment
hierarchy) then contains_rigid will return False.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bool</strong></dt>
<dd><p class="first last">True if the Compound contains any particle with a rigid_id != None</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The private variable ‘_check_if_contains_rigid_bodies’ is used to help
cache the status of ‘contains_rigid’. If ‘_check_if_contains_rigid_bodies’
is False, then the rigid body containment of the Compound has not changed,
and the particle tree is not traversed, boosting performance.</p>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.energy_minimize">
<code class="descname">energy_minimize</code><span class="sig-paren">(</span><em>forcefield='UFF'</em>, <em>steps=1000</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.energy_minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an energy minimization on a Compound</p>
<p>Default beahvior utilizes Open Babel (<a class="reference external" href="http://openbabel.org/docs/dev/">http://openbabel.org/docs/dev/</a>)
to perform an energy minimization/geometry optimization on a
Compound by applying a generic force field</p>
<p>Can also utilize OpenMM (<a class="reference external" href="http://openmm.org/">http://openmm.org/</a>) to energy minimize
after atomtyping a Compound using
Foyer (<a class="reference external" href="https://github.com/mosdef-hub/foyer">https://github.com/mosdef-hub/foyer</a>) to apply a forcefield
XML file that contains valid SMARTS strings.</p>
<p>This function is primarily intended to be used on smaller components,
with sizes on the order of 10’s to 100’s of particles, as the energy
minimization scales poorly with the number of particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>steps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1000</span></dt>
<dd><p class="first last">The number of optimization iterations</p>
</dd>
<dt><strong>forcefield</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’UFF’</span></dt>
<dd><p class="first last">The generic force field to apply to the Compound for minimization.
Valid options are ‘MMFF94’, ‘MMFF94s’, ‘’UFF’, ‘GAFF’, and ‘Ghemical’.
Please refer to the Open Babel documentation (<a class="reference external" href="http://open-babel">http://open-babel</a>.
readthedocs.io/en/latest/Forcefields/Overview.html) when considering
your choice of force field.
Utilizing OpenMM for energy minimization requires a forcefield
XML file with valid SMARTS strings. Please refer to (<a class="reference external" href="http://docs">http://docs</a>.
openmm.org/7.0.0/userguide/application.html#creating-force-fields)
for more information.</p>
</dd>
<dt><strong>Keyword Arguments</strong></dt>
<dd></dd>
<dt><strong>————</strong></dt>
<dd></dd>
<dt><strong>algorithm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’cg’</span></dt>
<dd><p class="first last">The energy minimization algorithm.  Valid options are ‘steep’,
‘cg’, and ‘md’, corresponding to steepest descent, conjugate
gradient, and equilibrium molecular dynamics respectively.
For _energy_minimize_openbabel</p>
</dd>
<dt><strong>scale_bonds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the bond force constant (1 is completely on).
For _energy_minimize_openmm</p>
</dd>
<dt><strong>scale_angles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the angle force constant (1 is completely on)
For _energy_minimize_openmm</p>
</dd>
<dt><strong>scale_torsions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the torsional force constants (1 is completely on)
For _energy_minimize_openmm
Note: Only Ryckaert-Bellemans style torsions are currently supported</p>
</dd>
<dt><strong>scale_nonbonded</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales epsilon (1 is completely on)
For _energy_minimize_openmm</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>If using _energy_minimize_openmm(), please cite:
.. [R734ef6a9e6a1-1] P. Eastman, M. S. Friedrichs, J. D. Chodera, R. J. Radmer,</p>
<blockquote>
<div>C. M. Bruns, J. P. Ku, K. A. Beauchamp, T. J. Lane,
L.-P. Wang, D. Shukla, T. Tye, M. Houston, T. Stich,
C. Klein, M. R. Shirts, and V. S. Pande.
“OpenMM 4: A Reusable, Extensible, Hardware Independent
Library for High Performance Molecular Simulation.”
J. Chem. Theor. Comput. 9(1): 461-469. (2013).</div></blockquote>
<p>If using _energy_minimize_openbabel(), please cite:
.. [R734ef6a9e6a1-1] O’Boyle, N.M.; Banck, M.; James, C.A.; Morley, C.;</p>
<blockquote>
<div>Vandermeersch, T.; Hutchison, G.R. “Open Babel: An open
chemical toolbox.” (2011) J. Cheminf. 3, 33</div></blockquote>
<table class="docutils citation" frame="void" id="r734ef6a9e6a1-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Open Babel, version X.X.X <a class="reference external" href="http://openbabel.org">http://openbabel.org</a>, (installed
Month Year)</td></tr>
</tbody>
</table>
<p>If using the ‘MMFF94’ force field please also cite the following:
.. [R734ef6a9e6a1-3] T.A. Halgren, “Merck molecular force field. I. Basis, form,</p>
<blockquote>
<div>scope, parameterization, and performance of MMFF94.” (1996)
J. Comput. Chem. 17, 490-519</div></blockquote>
<table class="docutils citation" frame="void" id="r734ef6a9e6a1-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>T.A. Halgren, “Merck molecular force field. II. MMFF94 van der
Waals and electrostatic parameters for intermolecular
interactions.” (1996) J. Comput. Chem. 17, 520-552</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r734ef6a9e6a1-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td>T.A. Halgren, “Merck molecular force field. III. Molecular
geometries and vibrational frequencies for MMFF94.” (1996)
J. Comput. Chem. 17, 553-586</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r734ef6a9e6a1-6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td>T.A. Halgren and R.B. Nachbar, “Merck molecular force field.
IV. Conformational energies and geometries for MMFF94.” (1996)
J. Comput. Chem. 17, 587-615</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r734ef6a9e6a1-7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td>T.A. Halgren, “Merck molecular force field. V. Extension of
MMFF94 using experimental data, additional computational data,
and empirical rules.” (1996) J. Comput. Chem. 17, 616-641</td></tr>
</tbody>
</table>
<p>If using the ‘MMFF94s’ force field please cite the above along with:
.. [R734ef6a9e6a1-8] T.A. Halgren, “MMFF VI. MMFF94s option for energy minimization</p>
<blockquote>
<div>studies.” (1999) J. Comput. Chem. 20, 720-729</div></blockquote>
<p>If using the ‘UFF’ force field please cite the following:
.. [R734ef6a9e6a1-3] Rappe, A.K., Casewit, C.J., Colwell, K.S., Goddard, W.A. III,</p>
<blockquote>
<div>Skiff, W.M. “UFF, a full periodic table force field for
molecular mechanics and molecular dynamics simulations.” (1992)
J. Am. Chem. Soc. 114, 10024-10039</div></blockquote>
<p>If using the ‘GAFF’ force field please cite the following:
.. [R734ef6a9e6a1-3] Wang, J., Wolf, R.M., Caldwell, J.W., Kollman, P.A., Case, D.A.</p>
<blockquote>
<div>“Development and testing of a general AMBER force field” (2004)
J. Comput. Chem. 25, 1157-1174</div></blockquote>
<p>If using the ‘Ghemical’ force field please cite the following:
.. [R734ef6a9e6a1-3] T. Hassinen and M. Perakyla, “New energy terms for reduced</p>
<blockquote>
<div>protein models implemented in an off-lattice force field” (2001)
J. Comput. Chem. 22, 1229-1242</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.from_parmed">
<code class="descname">from_parmed</code><span class="sig-paren">(</span><em>structure</em>, <em>coords_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.from_parmed" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract atoms and bonds from a pmd.Structure.</p>
<p>Will create sub-compounds for every chain if there is more than one
and sub-sub-compounds for every residue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>structure</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pmd.Structure</span></dt>
<dd><p class="first last">The structure to load.</p>
</dd>
<dt><strong>coords_only</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set preexisting atoms in compound to coordinates given by structure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.from_trajectory">
<code class="descname">from_trajectory</code><span class="sig-paren">(</span><em>traj</em>, <em>frame=-1</em>, <em>coords_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.from_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract atoms and bonds from a md.Trajectory.</p>
<p>Will create sub-compounds for every chain if there is more than one
and sub-sub-compounds for every residue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>traj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mdtraj.Trajectory</span></dt>
<dd><p class="first last">The trajectory to load.</p>
</dd>
<dt><strong>frame</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=-1 (last)</span></dt>
<dd><p class="first last">The frame to take coordinates from.</p>
</dd>
<dt><strong>coords_only</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Only read coordinate information</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.generate_bonds">
<code class="descname">generate_bonds</code><span class="sig-paren">(</span><em>name_a</em>, <em>name_b</em>, <em>dmin</em>, <em>dmax</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.generate_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Bonds between all pairs of types a/b within [dmin, dmax].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>name_a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of one of the Particles to be in each bond</p>
</dd>
<dt><strong>name_b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of the other Particle to be in each bond</p>
</dd>
<dt><strong>dmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum distance between Particles for considering a bond</p>
</dd>
<dt><strong>dmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum distance between Particles for considering a bond</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.label_rigid_bodies">
<code class="descname">label_rigid_bodies</code><span class="sig-paren">(</span><em>discrete_bodies=None</em>, <em>rigid_particles=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.label_rigid_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Designate which Compounds should be treated as rigid bodies</p>
<p>If no arguments are provided, this function will treat the compound
as a single rigid body by providing all particles in <cite>self</cite> with the
same rigid_id. If <cite>discrete_bodies</cite> is not None, each instance of
a Compound with a name found in <cite>discrete_bodies</cite> will be treated as a
unique rigid body. If <cite>rigid_particles</cite> is not None, only Particles
(Compounds at the bottom of the containment hierarchy) matching this name
will be considered part of the rigid body.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>discrete_bodies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional, default=None</span></dt>
<dd><p class="first last">Name(s) of Compound instances to be treated as unique rigid bodies.
Compound instances matching this (these) name(s) will be provided
with unique rigid_ids</p>
</dd>
<dt><strong>rigid_particles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional, default=None</span></dt>
<dd><p class="first last">Name(s) of Compound instances at the bottom of the containment
hierarchy (Particles) to be included in rigid bodies. Only Particles
matching this (these) name(s) will have their rigid_ids altered to
match the rigid body number.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Creating a rigid benzene</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">()</span>
</pre></div>
</div>
<p>Creating a semi-rigid benzene, where only the carbons are treated as
a rigid body</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">rigid_particles</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a box of rigid benzenes, where each benzene has a unique rigid
body ID.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Benzene&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">fill_box</span><span class="p">(</span><span class="n">benzene</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">n_compounds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">box</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">distinct_bodies</span><span class="o">=</span><span class="s1">&#39;Benzene&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a box of semi-rigid benzenes, where each benzene has a unique
rigid body ID and only the carbon portion is treated as rigid.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Benzene&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">fill_box</span><span class="p">(</span><span class="n">benzene</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">n_compounds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">box</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">distinct_bodies</span><span class="o">=</span><span class="s1">&#39;Benzene&#39;</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">rigid_particles</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.monolayer.Monolayer.max_rigid_id">
<code class="descname">max_rigid_id</code><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.max_rigid_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum rigid body ID contained in the Compound.</p>
<p>This is usually used by compound.root to determine the maximum
rigid_id in the containment hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int or None</strong></dt>
<dd><p class="first last">The maximum rigid body ID contained in the Compound. If no
rigid body IDs are found, None is returned</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.min_periodic_distance">
<code class="descname">min_periodic_distance</code><span class="sig-paren">(</span><em>xyz0</em>, <em>xyz1</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.min_periodic_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorized distance calculation considering minimum image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>xyz0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">Coordinates of first point</p>
</dd>
<dt><strong>xyz1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">Coordinates of second point</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>float</strong></dt>
<dd><p class="first last">Vectorized distance between the two points following minimum
image convention</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.monolayer.Monolayer.n_bonds">
<code class="descname">n_bonds</code><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.n_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of bonds in the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int</strong></dt>
<dd><p class="first last">The number of bonds in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.monolayer.Monolayer.n_particles">
<code class="descname">n_particles</code><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.n_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of Particles in the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int</strong></dt>
<dd><p class="first last">The number of Particles in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.particles">
<code class="descname">particles</code><span class="sig-paren">(</span><em>include_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Particles of the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>include_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Include port particles</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.particles_by_name">
<code class="descname">particles_by_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.particles_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Particles of the Compound with a specific name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Only particles with this name are returned</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle in the Compound with the user-specified name</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.particles_in_range">
<code class="descname">particles_in_range</code><span class="sig-paren">(</span><em>compound</em>, <em>dmax</em>, <em>max_particles=20</em>, <em>particle_kdtree=None</em>, <em>particle_array=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.particles_in_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Find particles within a specified range of another particle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>compound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd><p class="first last">Reference particle to find other particles in range of</p>
</dd>
<dt><strong>dmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum distance from ‘compound’ to look for Particles</p>
</dd>
<dt><strong>max_particles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=20</span></dt>
<dd><p class="first last">Maximum number of Particles to return</p>
</dd>
<dt><strong>particle_kdtree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.PeriodicCKDTree, optional</span></dt>
<dd><p class="first last">KD-tree for looking up nearest neighbors. If not provided, a KD-
tree will be generated from all Particles in self</p>
</dd>
<dt><strong>particle_array</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=mb.Compound, optional</span></dt>
<dd><p class="first last">Array of possible particles to consider for return. If not
provided, this defaults to all Particles in self</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>np.ndarray, shape=(n,), dtype=mb.Compound</strong></dt>
<dd><p class="first last">Particles in range of compound according to user-defined limits</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">periodic_kdtree.PerioidicCKDTree</span></code></dt>
<dd>mBuild implementation of kd-trees</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.spatial.ckdtree</span></code></dt>
<dd>Further details on kd-trees</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.referenced_ports">
<code class="descname">referenced_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.referenced_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Ports referenced by this Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all ports referenced by the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>objs_to_remove</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove children from the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>objs_to_remove</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list of mb.Compound</span></dt>
<dd><p class="first last">The Compound(s) to be removed from self</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.remove_bond">
<code class="descname">remove_bond</code><span class="sig-paren">(</span><em>particle_pair</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.remove_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a bond between a pair of Particles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>particle_pair</strong> <span class="classifier-delimiter">:</span> <span class="classifier">indexable object, length=2, dtype=mb.Compound</span></dt>
<dd><p class="first last">The pair of Particles to remove the bond between</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.rigid_particles">
<code class="descname">rigid_particles</code><span class="sig-paren">(</span><em>rigid_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.rigid_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all particles in rigid bodies.</p>
<p>If a rigid_id is specified, then this function will only yield particles
with a matching rigid_id.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rigid_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Include only particles with this rigid body ID</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next particle with a rigid_id that is not None, or the next
particle with a matching rigid_id if specified</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.monolayer.Monolayer.root">
<code class="descname">root</code><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.root" title="Permalink to this definition">¶</a></dt>
<dd><p>The Compound at the top of self’s hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The Compound at the top of self’s hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>theta</em>, <em>around</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate Compound around an arbitrary vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The angle by which to rotate the Compound, in radians.</p>
</dd>
<dt><strong>around</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">The vector about which to rotate the Compound.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>show_ports=False</em>, <em>forcefield_name=None</em>, <em>forcefield_files=None</em>, <em>forcefield_debug=False</em>, <em>box=None</em>, <em>overwrite=False</em>, <em>residues=None</em>, <em>references_file=None</em>, <em>combining_rule='lorentz'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the Compound to a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Filesystem path in which to save the trajectory. The extension or
prefix will be parsed and control the format. Supported
extensions are: ‘hoomdxml’, ‘gsd’, ‘gro’, ‘top’, ‘lammps’, ‘lmp’</p>
</dd>
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Save ports contained within the compound.</p>
</dd>
<dt><strong>forcefield_files</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Apply a forcefield to the output file using a forcefield provided
by the <cite>foyer</cite> package.</p>
</dd>
<dt><strong>forcefield_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Apply a named forcefield to the output file using the <cite>foyer</cite>
package, e.g. ‘oplsaa’. Forcefields listed here:
<a class="reference external" href="https://github.com/mosdef-hub/foyer/tree/master/foyer/forcefields">https://github.com/mosdef-hub/foyer/tree/master/foyer/forcefields</a></p>
</dd>
<dt><strong>forcefield_debug</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Choose level of verbosity when applying a forcefield through <cite>foyer</cite>.
Specifically, when missing atom types in the forcefield xml file,
determine if the warning is condensed or verbose.</p>
</dd>
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be written to the output file. If ‘None’, a
bounding box is used with 0.25nm buffers at each face to avoid
overlapping atoms.</p>
</dd>
<dt><strong>overwrite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Overwrite if the filename already exists</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>references_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Specify a filename to write references for the forcefield that is
to be applied. References are written in BiBTeX format.</p>
</dd>
<dt><strong>combining_rule</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’lorentz’</span></dt>
<dd><p class="first last">Specify the combining rule for nonbonded interactions. Only relevant
when the <cite>foyer</cite> package is used to apply a forcefield. Valid
options are ‘lorentz’ and ‘geometric’, specifying Lorentz-Berthelot
and geometric combining rules respectively.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>ref_distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting distance values to reduced units.</p>
</dd>
<dt><strong>ref_energy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting energy values to reduced units.</p>
</dd>
<dt><strong>ref_mass</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting mass values to reduced units.</p>
</dd>
<dt><strong>atom_style: str, default=’full’</strong></dt>
<dd><p class="first last">Defines the style of atoms to be saved in a LAMMPS data file. The following atom
styles are currently supported: ‘full’, ‘atomic’, ‘charge’, ‘molecular’
see <a class="reference external" href="http://lammps.sandia.gov/doc/atom_style.html">http://lammps.sandia.gov/doc/atom_style.html</a> for more
information on atom styles.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.gsdwrite.write_gsd</span></code></dt>
<dd>Write to GSD format</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.hoomdxml.write_hoomdxml</span></code></dt>
<dd>Write to Hoomd XML format</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.lammpsdata.write_lammpsdata</span></code></dt>
<dd>Write to LAMMPS data format</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.spin">
<code class="descname">spin</code><span class="sig-paren">(</span><em>theta</em>, <em>around</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate Compound in place around an arbitrary vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The angle by which to rotate the Compound, in radians.</p>
</dd>
<dt><strong>around</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">The axis about which to spin the Compound.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.successors">
<code class="descname">successors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield Compounds below self in the hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle below self in the hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.to_intermol">
<code class="descname">to_intermol</code><span class="sig-paren">(</span><em>molecule_types=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.to_intermol" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an InterMol system from a Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>molecule_types</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or tuple of subclasses of Compound</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>intermol_system</strong> <span class="classifier-delimiter">:</span> <span class="classifier">intermol.system.System</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.to_parmed">
<code class="descname">to_parmed</code><span class="sig-paren">(</span><em>box=None</em>, <em>title=''</em>, <em>residues=None</em>, <em>show_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.to_parmed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a ParmEd Structure from a Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be used when converting to a <cite>Structure</cite>.
If ‘None’, a bounding box is used with 0.25nm buffers at
each face to avoid overlapping atoms, unless <cite>self.periodicity</cite>
is not None, in which case those values are used for the
box lengths.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=self.name</span></dt>
<dd><p class="first last">Title/name of the ParmEd Structure</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional, default=False</span></dt>
<dd><p class="first last">Include all port atoms when converting to a <cite>Structure</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>parmed.structure.Structure</strong></dt>
<dd><p class="first last">ParmEd Structure object converted from self</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">parmed.structure.Structure</span></code></dt>
<dd>Details on the ParmEd Structure object</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.to_trajectory">
<code class="descname">to_trajectory</code><span class="sig-paren">(</span><em>show_ports=False</em>, <em>chains=None</em>, <em>residues=None</em>, <em>box=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.to_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to an md.Trajectory and flatten the compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Include all port atoms when converting to trajectory.</p>
</dd>
<dt><strong>chains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list of mb.Compound</span></dt>
<dd><p class="first last">Chain types to add to the topology</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be used when converting to a <cite>Trajectory</cite>.
If ‘None’, a bounding box is used with a 0.5nm buffer in each
dimension. to avoid overlapping atoms, unless <cite>self.periodicity</cite>
is not None, in which case those values are used for the
box lengths.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trajectory</strong> <span class="classifier-delimiter">:</span> <span class="classifier">md.Trajectory</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_to_topology</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>by</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the Compound by a vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.translate_to">
<code class="descname">translate_to</code><span class="sig-paren">(</span><em>pos</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.translate_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the Compound to a specific position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=3(,), dtype=float</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.unlabel_rigid_bodies">
<code class="descname">unlabel_rigid_bodies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.unlabel_rigid_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all rigid body labels from the Compound</p>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.update_coordinates">
<code class="descname">update_coordinates</code><span class="sig-paren">(</span><em>filename</em>, <em>update_port_locations=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.update_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the coordinates of this Compound from a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of file from which to load coordinates. Supported file types
are the same as those supported by load()</p>
</dd>
<dt><strong>update_port_locations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Update the locations of Ports so that they are shifted along with
their anchor particles.  Note: This conserves the location of
Ports with respect to the anchor Particle, but does not conserve
the orientation of Ports with respect to the molecule as a whole.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">load</span></code></dt>
<dd>Load coordinates from a file</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.monolayer.Monolayer.visualize">
<code class="descname">visualize</code><span class="sig-paren">(</span><em>show_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.visualize" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the Compound using nglview.</p>
<p>Allows for visualization of a Compound within a Jupyter Notebook.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Visualize Ports in addition to Particles</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.monolayer.Monolayer.xyz">
<code class="descname">xyz</code><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all particle coordinates in this compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 3), dtype=float</span></dt>
<dd><p class="first last">Array with the positions of all particles.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.monolayer.Monolayer.xyz_with_ports">
<code class="descname">xyz_with_ports</code><a class="headerlink" href="#mbuild.recipes.monolayer.Monolayer.xyz_with_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all particle coordinates in this compound including ports.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 3), dtype=float</span></dt>
<dd><p class="first last">Array with the positions of all particles and ports.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="polymer">
<h2>Polymer<a class="headerlink" href="#polymer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="mbuild.recipes.polymer.Polymer">
<em class="property">class </em><code class="descclassname">mbuild.recipes.polymer.</code><code class="descname">Polymer</code><span class="sig-paren">(</span><em>monomers</em>, <em>n</em>, <em>sequence='A'</em>, <em>port_labels=('up'</em>, <em>'down')</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mbuild/recipes/polymer.html#Polymer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mbuild.recipes.polymer.Polymer" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect one or more components in a specified sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>monomers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list of mb.Compound</span></dt>
<dd><p class="first last">The compound(s) to replicate.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of times to replicate the sequence.</p>
</dd>
<dt><strong>sequence</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’A’</span></dt>
<dd><p class="first last">A string of characters where each unique character represents one
repetition of a monomer. Characters in <cite>sequence</cite> are assigned to
monomers in the order assigned by the built-in <cite>sorted()</cite>.</p>
</dd>
<dt><strong>port_labels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-tuple of strs, optional, default=(‘up’, ‘down’)</span></dt>
<dd><p class="first last">The names of the two ports to use to connect copies of proto.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>new_child</em>, <em>label=None</em>, <em>containment=True</em>, <em>replace=False</em>, <em>inherit_periodicity=True</em>, <em>reset_rigid_ids=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a part to the Compound.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>This does not necessarily add the part to self.children but may
instead be used to add a reference to the part to self.labels. See
‘containment’ argument.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_child</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list-like of mb.Compound</span></dt>
<dd><p class="first last">The object(s) to be added to this Compound.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">A descriptive string for the part.</p>
</dd>
<dt><strong>containment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Add the part to self.children.</p>
</dd>
<dt><strong>replace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Replace the label if it already exists.</p>
</dd>
<dt><strong>inherit_periodicity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Replace the periodicity of self with the periodicity of the
Compound being added</p>
</dd>
<dt><strong>reset_rigid_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">If the Compound to be added contains rigid bodies, reset the
rigid_ids such that values remain distinct from rigid_ids
already present in <cite>self</cite>. Can be set to False if attempting
to add Compounds to an existing rigid body.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.add_bond">
<code class="descname">add_bond</code><span class="sig-paren">(</span><em>particle_pair</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.add_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a bond between two Particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>particle_pair</strong> <span class="classifier-delimiter">:</span> <span class="classifier">indexable object, length=2, dtype=mb.Compound</span></dt>
<dd><p class="first last">The pair of Particles to add a bond between</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.all_ports">
<code class="descname">all_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.all_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Ports referenced by this Compound and its successors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all Ports referenced by this Compound and its successors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.ancestors">
<code class="descname">ancestors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.ancestors" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all ancestors of the Compound recursively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Compound above self in the hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.available_ports">
<code class="descname">available_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.available_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all unoccupied Ports referenced by this Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all unoccupied ports referenced by the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.bonds">
<code class="descname">bonds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all bonds in the Compound and sub-Compounds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple of mb.Compound</strong></dt>
<dd><p class="first last">The next bond in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bond_graph.edges_iter</span></code></dt>
<dd>Iterates over all edges in a BondGraph</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.polymer.Polymer.boundingbox">
<code class="descname">boundingbox</code><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.boundingbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bounding box of the compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Box</strong></dt>
<dd><p class="first last">The bounding box for this Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.polymer.Polymer.center">
<code class="descname">center</code><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.center" title="Permalink to this definition">¶</a></dt>
<dd><p>The cartesian center of the Compound based on its Particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>np.ndarray, shape=(3,), dtype=float</strong></dt>
<dd><p class="first last">The cartesian center of the Compound based on its Particles</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.polymer.Polymer.contains_rigid">
<code class="descname">contains_rigid</code><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.contains_rigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the Compound contains rigid bodies</p>
<p>If the Compound contains any particle with a rigid_id != None
then contains_rigid will return True. If the Compound has no
children (i.e. the Compound resides at the bottom of the containment
hierarchy) then contains_rigid will return False.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bool</strong></dt>
<dd><p class="first last">True if the Compound contains any particle with a rigid_id != None</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The private variable ‘_check_if_contains_rigid_bodies’ is used to help
cache the status of ‘contains_rigid’. If ‘_check_if_contains_rigid_bodies’
is False, then the rigid body containment of the Compound has not changed,
and the particle tree is not traversed, boosting performance.</p>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.energy_minimize">
<code class="descname">energy_minimize</code><span class="sig-paren">(</span><em>forcefield='UFF'</em>, <em>steps=1000</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.energy_minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an energy minimization on a Compound</p>
<p>Default beahvior utilizes Open Babel (<a class="reference external" href="http://openbabel.org/docs/dev/">http://openbabel.org/docs/dev/</a>)
to perform an energy minimization/geometry optimization on a
Compound by applying a generic force field</p>
<p>Can also utilize OpenMM (<a class="reference external" href="http://openmm.org/">http://openmm.org/</a>) to energy minimize
after atomtyping a Compound using
Foyer (<a class="reference external" href="https://github.com/mosdef-hub/foyer">https://github.com/mosdef-hub/foyer</a>) to apply a forcefield
XML file that contains valid SMARTS strings.</p>
<p>This function is primarily intended to be used on smaller components,
with sizes on the order of 10’s to 100’s of particles, as the energy
minimization scales poorly with the number of particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>steps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1000</span></dt>
<dd><p class="first last">The number of optimization iterations</p>
</dd>
<dt><strong>forcefield</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’UFF’</span></dt>
<dd><p class="first last">The generic force field to apply to the Compound for minimization.
Valid options are ‘MMFF94’, ‘MMFF94s’, ‘’UFF’, ‘GAFF’, and ‘Ghemical’.
Please refer to the Open Babel documentation (<a class="reference external" href="http://open-babel">http://open-babel</a>.
readthedocs.io/en/latest/Forcefields/Overview.html) when considering
your choice of force field.
Utilizing OpenMM for energy minimization requires a forcefield
XML file with valid SMARTS strings. Please refer to (<a class="reference external" href="http://docs">http://docs</a>.
openmm.org/7.0.0/userguide/application.html#creating-force-fields)
for more information.</p>
</dd>
<dt><strong>Keyword Arguments</strong></dt>
<dd></dd>
<dt><strong>————</strong></dt>
<dd></dd>
<dt><strong>algorithm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’cg’</span></dt>
<dd><p class="first last">The energy minimization algorithm.  Valid options are ‘steep’,
‘cg’, and ‘md’, corresponding to steepest descent, conjugate
gradient, and equilibrium molecular dynamics respectively.
For _energy_minimize_openbabel</p>
</dd>
<dt><strong>scale_bonds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the bond force constant (1 is completely on).
For _energy_minimize_openmm</p>
</dd>
<dt><strong>scale_angles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the angle force constant (1 is completely on)
For _energy_minimize_openmm</p>
</dd>
<dt><strong>scale_torsions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the torsional force constants (1 is completely on)
For _energy_minimize_openmm
Note: Only Ryckaert-Bellemans style torsions are currently supported</p>
</dd>
<dt><strong>scale_nonbonded</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales epsilon (1 is completely on)
For _energy_minimize_openmm</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>If using _energy_minimize_openmm(), please cite:
.. [Raf7507511f76-1] P. Eastman, M. S. Friedrichs, J. D. Chodera, R. J. Radmer,</p>
<blockquote>
<div>C. M. Bruns, J. P. Ku, K. A. Beauchamp, T. J. Lane,
L.-P. Wang, D. Shukla, T. Tye, M. Houston, T. Stich,
C. Klein, M. R. Shirts, and V. S. Pande.
“OpenMM 4: A Reusable, Extensible, Hardware Independent
Library for High Performance Molecular Simulation.”
J. Chem. Theor. Comput. 9(1): 461-469. (2013).</div></blockquote>
<p>If using _energy_minimize_openbabel(), please cite:
.. [Raf7507511f76-1] O’Boyle, N.M.; Banck, M.; James, C.A.; Morley, C.;</p>
<blockquote>
<div>Vandermeersch, T.; Hutchison, G.R. “Open Babel: An open
chemical toolbox.” (2011) J. Cheminf. 3, 33</div></blockquote>
<table class="docutils citation" frame="void" id="raf7507511f76-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[2]</a></td><td>Open Babel, version X.X.X <a class="reference external" href="http://openbabel.org">http://openbabel.org</a>, (installed
Month Year)</td></tr>
</tbody>
</table>
<p>If using the ‘MMFF94’ force field please also cite the following:
.. [Raf7507511f76-3] T.A. Halgren, “Merck molecular force field. I. Basis, form,</p>
<blockquote>
<div>scope, parameterization, and performance of MMFF94.” (1996)
J. Comput. Chem. 17, 490-519</div></blockquote>
<table class="docutils citation" frame="void" id="raf7507511f76-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[4]</a></td><td>T.A. Halgren, “Merck molecular force field. II. MMFF94 van der
Waals and electrostatic parameters for intermolecular
interactions.” (1996) J. Comput. Chem. 17, 520-552</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="raf7507511f76-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[5]</a></td><td>T.A. Halgren, “Merck molecular force field. III. Molecular
geometries and vibrational frequencies for MMFF94.” (1996)
J. Comput. Chem. 17, 553-586</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="raf7507511f76-6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[6]</a></td><td>T.A. Halgren and R.B. Nachbar, “Merck molecular force field.
IV. Conformational energies and geometries for MMFF94.” (1996)
J. Comput. Chem. 17, 587-615</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="raf7507511f76-7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[7]</a></td><td>T.A. Halgren, “Merck molecular force field. V. Extension of
MMFF94 using experimental data, additional computational data,
and empirical rules.” (1996) J. Comput. Chem. 17, 616-641</td></tr>
</tbody>
</table>
<p>If using the ‘MMFF94s’ force field please cite the above along with:
.. [Raf7507511f76-8] T.A. Halgren, “MMFF VI. MMFF94s option for energy minimization</p>
<blockquote>
<div>studies.” (1999) J. Comput. Chem. 20, 720-729</div></blockquote>
<p>If using the ‘UFF’ force field please cite the following:
.. [Raf7507511f76-3] Rappe, A.K., Casewit, C.J., Colwell, K.S., Goddard, W.A. III,</p>
<blockquote>
<div>Skiff, W.M. “UFF, a full periodic table force field for
molecular mechanics and molecular dynamics simulations.” (1992)
J. Am. Chem. Soc. 114, 10024-10039</div></blockquote>
<p>If using the ‘GAFF’ force field please cite the following:
.. [Raf7507511f76-3] Wang, J., Wolf, R.M., Caldwell, J.W., Kollman, P.A., Case, D.A.</p>
<blockquote>
<div>“Development and testing of a general AMBER force field” (2004)
J. Comput. Chem. 25, 1157-1174</div></blockquote>
<p>If using the ‘Ghemical’ force field please cite the following:
.. [Raf7507511f76-3] T. Hassinen and M. Perakyla, “New energy terms for reduced</p>
<blockquote>
<div>protein models implemented in an off-lattice force field” (2001)
J. Comput. Chem. 22, 1229-1242</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.from_parmed">
<code class="descname">from_parmed</code><span class="sig-paren">(</span><em>structure</em>, <em>coords_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.from_parmed" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract atoms and bonds from a pmd.Structure.</p>
<p>Will create sub-compounds for every chain if there is more than one
and sub-sub-compounds for every residue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>structure</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pmd.Structure</span></dt>
<dd><p class="first last">The structure to load.</p>
</dd>
<dt><strong>coords_only</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set preexisting atoms in compound to coordinates given by structure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.from_trajectory">
<code class="descname">from_trajectory</code><span class="sig-paren">(</span><em>traj</em>, <em>frame=-1</em>, <em>coords_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.from_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract atoms and bonds from a md.Trajectory.</p>
<p>Will create sub-compounds for every chain if there is more than one
and sub-sub-compounds for every residue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>traj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mdtraj.Trajectory</span></dt>
<dd><p class="first last">The trajectory to load.</p>
</dd>
<dt><strong>frame</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=-1 (last)</span></dt>
<dd><p class="first last">The frame to take coordinates from.</p>
</dd>
<dt><strong>coords_only</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Only read coordinate information</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.generate_bonds">
<code class="descname">generate_bonds</code><span class="sig-paren">(</span><em>name_a</em>, <em>name_b</em>, <em>dmin</em>, <em>dmax</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.generate_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Bonds between all pairs of types a/b within [dmin, dmax].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>name_a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of one of the Particles to be in each bond</p>
</dd>
<dt><strong>name_b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of the other Particle to be in each bond</p>
</dd>
<dt><strong>dmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum distance between Particles for considering a bond</p>
</dd>
<dt><strong>dmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum distance between Particles for considering a bond</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.label_rigid_bodies">
<code class="descname">label_rigid_bodies</code><span class="sig-paren">(</span><em>discrete_bodies=None</em>, <em>rigid_particles=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.label_rigid_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Designate which Compounds should be treated as rigid bodies</p>
<p>If no arguments are provided, this function will treat the compound
as a single rigid body by providing all particles in <cite>self</cite> with the
same rigid_id. If <cite>discrete_bodies</cite> is not None, each instance of
a Compound with a name found in <cite>discrete_bodies</cite> will be treated as a
unique rigid body. If <cite>rigid_particles</cite> is not None, only Particles
(Compounds at the bottom of the containment hierarchy) matching this name
will be considered part of the rigid body.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>discrete_bodies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional, default=None</span></dt>
<dd><p class="first last">Name(s) of Compound instances to be treated as unique rigid bodies.
Compound instances matching this (these) name(s) will be provided
with unique rigid_ids</p>
</dd>
<dt><strong>rigid_particles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional, default=None</span></dt>
<dd><p class="first last">Name(s) of Compound instances at the bottom of the containment
hierarchy (Particles) to be included in rigid bodies. Only Particles
matching this (these) name(s) will have their rigid_ids altered to
match the rigid body number.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Creating a rigid benzene</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">()</span>
</pre></div>
</div>
<p>Creating a semi-rigid benzene, where only the carbons are treated as
a rigid body</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">rigid_particles</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a box of rigid benzenes, where each benzene has a unique rigid
body ID.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Benzene&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">fill_box</span><span class="p">(</span><span class="n">benzene</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">n_compounds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">box</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">distinct_bodies</span><span class="o">=</span><span class="s1">&#39;Benzene&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a box of semi-rigid benzenes, where each benzene has a unique
rigid body ID and only the carbon portion is treated as rigid.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Benzene&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">fill_box</span><span class="p">(</span><span class="n">benzene</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">n_compounds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">box</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">distinct_bodies</span><span class="o">=</span><span class="s1">&#39;Benzene&#39;</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">rigid_particles</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.polymer.Polymer.max_rigid_id">
<code class="descname">max_rigid_id</code><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.max_rigid_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum rigid body ID contained in the Compound.</p>
<p>This is usually used by compound.root to determine the maximum
rigid_id in the containment hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int or None</strong></dt>
<dd><p class="first last">The maximum rigid body ID contained in the Compound. If no
rigid body IDs are found, None is returned</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.min_periodic_distance">
<code class="descname">min_periodic_distance</code><span class="sig-paren">(</span><em>xyz0</em>, <em>xyz1</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.min_periodic_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorized distance calculation considering minimum image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>xyz0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">Coordinates of first point</p>
</dd>
<dt><strong>xyz1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">Coordinates of second point</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>float</strong></dt>
<dd><p class="first last">Vectorized distance between the two points following minimum
image convention</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.polymer.Polymer.n_bonds">
<code class="descname">n_bonds</code><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.n_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of bonds in the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int</strong></dt>
<dd><p class="first last">The number of bonds in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.polymer.Polymer.n_particles">
<code class="descname">n_particles</code><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.n_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of Particles in the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int</strong></dt>
<dd><p class="first last">The number of Particles in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.particles">
<code class="descname">particles</code><span class="sig-paren">(</span><em>include_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Particles of the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>include_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Include port particles</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.particles_by_name">
<code class="descname">particles_by_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.particles_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Particles of the Compound with a specific name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Only particles with this name are returned</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle in the Compound with the user-specified name</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.particles_in_range">
<code class="descname">particles_in_range</code><span class="sig-paren">(</span><em>compound</em>, <em>dmax</em>, <em>max_particles=20</em>, <em>particle_kdtree=None</em>, <em>particle_array=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.particles_in_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Find particles within a specified range of another particle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>compound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd><p class="first last">Reference particle to find other particles in range of</p>
</dd>
<dt><strong>dmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum distance from ‘compound’ to look for Particles</p>
</dd>
<dt><strong>max_particles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=20</span></dt>
<dd><p class="first last">Maximum number of Particles to return</p>
</dd>
<dt><strong>particle_kdtree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.PeriodicCKDTree, optional</span></dt>
<dd><p class="first last">KD-tree for looking up nearest neighbors. If not provided, a KD-
tree will be generated from all Particles in self</p>
</dd>
<dt><strong>particle_array</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=mb.Compound, optional</span></dt>
<dd><p class="first last">Array of possible particles to consider for return. If not
provided, this defaults to all Particles in self</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>np.ndarray, shape=(n,), dtype=mb.Compound</strong></dt>
<dd><p class="first last">Particles in range of compound according to user-defined limits</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">periodic_kdtree.PerioidicCKDTree</span></code></dt>
<dd>mBuild implementation of kd-trees</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.spatial.ckdtree</span></code></dt>
<dd>Further details on kd-trees</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.referenced_ports">
<code class="descname">referenced_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.referenced_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Ports referenced by this Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all ports referenced by the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>objs_to_remove</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove children from the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>objs_to_remove</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list of mb.Compound</span></dt>
<dd><p class="first last">The Compound(s) to be removed from self</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.remove_bond">
<code class="descname">remove_bond</code><span class="sig-paren">(</span><em>particle_pair</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.remove_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a bond between a pair of Particles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>particle_pair</strong> <span class="classifier-delimiter">:</span> <span class="classifier">indexable object, length=2, dtype=mb.Compound</span></dt>
<dd><p class="first last">The pair of Particles to remove the bond between</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.rigid_particles">
<code class="descname">rigid_particles</code><span class="sig-paren">(</span><em>rigid_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.rigid_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all particles in rigid bodies.</p>
<p>If a rigid_id is specified, then this function will only yield particles
with a matching rigid_id.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rigid_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Include only particles with this rigid body ID</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next particle with a rigid_id that is not None, or the next
particle with a matching rigid_id if specified</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.polymer.Polymer.root">
<code class="descname">root</code><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.root" title="Permalink to this definition">¶</a></dt>
<dd><p>The Compound at the top of self’s hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The Compound at the top of self’s hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>theta</em>, <em>around</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate Compound around an arbitrary vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The angle by which to rotate the Compound, in radians.</p>
</dd>
<dt><strong>around</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">The vector about which to rotate the Compound.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>show_ports=False</em>, <em>forcefield_name=None</em>, <em>forcefield_files=None</em>, <em>forcefield_debug=False</em>, <em>box=None</em>, <em>overwrite=False</em>, <em>residues=None</em>, <em>references_file=None</em>, <em>combining_rule='lorentz'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the Compound to a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Filesystem path in which to save the trajectory. The extension or
prefix will be parsed and control the format. Supported
extensions are: ‘hoomdxml’, ‘gsd’, ‘gro’, ‘top’, ‘lammps’, ‘lmp’</p>
</dd>
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Save ports contained within the compound.</p>
</dd>
<dt><strong>forcefield_files</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Apply a forcefield to the output file using a forcefield provided
by the <cite>foyer</cite> package.</p>
</dd>
<dt><strong>forcefield_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Apply a named forcefield to the output file using the <cite>foyer</cite>
package, e.g. ‘oplsaa’. Forcefields listed here:
<a class="reference external" href="https://github.com/mosdef-hub/foyer/tree/master/foyer/forcefields">https://github.com/mosdef-hub/foyer/tree/master/foyer/forcefields</a></p>
</dd>
<dt><strong>forcefield_debug</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Choose level of verbosity when applying a forcefield through <cite>foyer</cite>.
Specifically, when missing atom types in the forcefield xml file,
determine if the warning is condensed or verbose.</p>
</dd>
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be written to the output file. If ‘None’, a
bounding box is used with 0.25nm buffers at each face to avoid
overlapping atoms.</p>
</dd>
<dt><strong>overwrite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Overwrite if the filename already exists</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>references_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Specify a filename to write references for the forcefield that is
to be applied. References are written in BiBTeX format.</p>
</dd>
<dt><strong>combining_rule</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’lorentz’</span></dt>
<dd><p class="first last">Specify the combining rule for nonbonded interactions. Only relevant
when the <cite>foyer</cite> package is used to apply a forcefield. Valid
options are ‘lorentz’ and ‘geometric’, specifying Lorentz-Berthelot
and geometric combining rules respectively.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>ref_distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting distance values to reduced units.</p>
</dd>
<dt><strong>ref_energy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting energy values to reduced units.</p>
</dd>
<dt><strong>ref_mass</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting mass values to reduced units.</p>
</dd>
<dt><strong>atom_style: str, default=’full’</strong></dt>
<dd><p class="first last">Defines the style of atoms to be saved in a LAMMPS data file. The following atom
styles are currently supported: ‘full’, ‘atomic’, ‘charge’, ‘molecular’
see <a class="reference external" href="http://lammps.sandia.gov/doc/atom_style.html">http://lammps.sandia.gov/doc/atom_style.html</a> for more
information on atom styles.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.gsdwrite.write_gsd</span></code></dt>
<dd>Write to GSD format</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.hoomdxml.write_hoomdxml</span></code></dt>
<dd>Write to Hoomd XML format</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.lammpsdata.write_lammpsdata</span></code></dt>
<dd>Write to LAMMPS data format</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.spin">
<code class="descname">spin</code><span class="sig-paren">(</span><em>theta</em>, <em>around</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate Compound in place around an arbitrary vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The angle by which to rotate the Compound, in radians.</p>
</dd>
<dt><strong>around</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">The axis about which to spin the Compound.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.successors">
<code class="descname">successors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield Compounds below self in the hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle below self in the hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.to_intermol">
<code class="descname">to_intermol</code><span class="sig-paren">(</span><em>molecule_types=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.to_intermol" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an InterMol system from a Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>molecule_types</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or tuple of subclasses of Compound</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>intermol_system</strong> <span class="classifier-delimiter">:</span> <span class="classifier">intermol.system.System</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.to_parmed">
<code class="descname">to_parmed</code><span class="sig-paren">(</span><em>box=None</em>, <em>title=''</em>, <em>residues=None</em>, <em>show_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.to_parmed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a ParmEd Structure from a Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be used when converting to a <cite>Structure</cite>.
If ‘None’, a bounding box is used with 0.25nm buffers at
each face to avoid overlapping atoms, unless <cite>self.periodicity</cite>
is not None, in which case those values are used for the
box lengths.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=self.name</span></dt>
<dd><p class="first last">Title/name of the ParmEd Structure</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional, default=False</span></dt>
<dd><p class="first last">Include all port atoms when converting to a <cite>Structure</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>parmed.structure.Structure</strong></dt>
<dd><p class="first last">ParmEd Structure object converted from self</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">parmed.structure.Structure</span></code></dt>
<dd>Details on the ParmEd Structure object</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.to_trajectory">
<code class="descname">to_trajectory</code><span class="sig-paren">(</span><em>show_ports=False</em>, <em>chains=None</em>, <em>residues=None</em>, <em>box=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.to_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to an md.Trajectory and flatten the compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Include all port atoms when converting to trajectory.</p>
</dd>
<dt><strong>chains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list of mb.Compound</span></dt>
<dd><p class="first last">Chain types to add to the topology</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be used when converting to a <cite>Trajectory</cite>.
If ‘None’, a bounding box is used with a 0.5nm buffer in each
dimension. to avoid overlapping atoms, unless <cite>self.periodicity</cite>
is not None, in which case those values are used for the
box lengths.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trajectory</strong> <span class="classifier-delimiter">:</span> <span class="classifier">md.Trajectory</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_to_topology</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>by</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the Compound by a vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.translate_to">
<code class="descname">translate_to</code><span class="sig-paren">(</span><em>pos</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.translate_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the Compound to a specific position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=3(,), dtype=float</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.unlabel_rigid_bodies">
<code class="descname">unlabel_rigid_bodies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.unlabel_rigid_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all rigid body labels from the Compound</p>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.update_coordinates">
<code class="descname">update_coordinates</code><span class="sig-paren">(</span><em>filename</em>, <em>update_port_locations=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.update_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the coordinates of this Compound from a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of file from which to load coordinates. Supported file types
are the same as those supported by load()</p>
</dd>
<dt><strong>update_port_locations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Update the locations of Ports so that they are shifted along with
their anchor particles.  Note: This conserves the location of
Ports with respect to the anchor Particle, but does not conserve
the orientation of Ports with respect to the molecule as a whole.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">load</span></code></dt>
<dd>Load coordinates from a file</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.polymer.Polymer.visualize">
<code class="descname">visualize</code><span class="sig-paren">(</span><em>show_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.visualize" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the Compound using nglview.</p>
<p>Allows for visualization of a Compound within a Jupyter Notebook.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Visualize Ports in addition to Particles</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.polymer.Polymer.xyz">
<code class="descname">xyz</code><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all particle coordinates in this compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 3), dtype=float</span></dt>
<dd><p class="first last">Array with the positions of all particles.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.polymer.Polymer.xyz_with_ports">
<code class="descname">xyz_with_ports</code><a class="headerlink" href="#mbuild.recipes.polymer.Polymer.xyz_with_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all particle coordinates in this compound including ports.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 3), dtype=float</span></dt>
<dd><p class="first last">Array with the positions of all particles and ports.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tiled-compound">
<h2>Tiled Compound<a class="headerlink" href="#tiled-compound" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="mbuild.recipes.tiled_compound.TiledCompound">
<em class="property">class </em><code class="descclassname">mbuild.recipes.tiled_compound.</code><code class="descname">TiledCompound</code><span class="sig-paren">(</span><em>tile</em>, <em>n_tiles</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mbuild/recipes/tiled_compound.html#TiledCompound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound" title="Permalink to this definition">¶</a></dt>
<dd><p>Replicates a Compound in any cartesian direction(s).</p>
<p>Correctly updates connectivity while respecting periodic boundary
conditions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tile</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd><p class="first last">The Compound to be replicated.</p>
</dd>
<dt><strong>n_tiles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape=(3,), dtype=int, optional, default=(1, 1, 1)</span></dt>
<dd><p class="first last">Number of times to replicate tile in the x, y and z-directions.</p>
</dd>
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=tile.name</span></dt>
<dd><p class="first last">Descriptive string for the compound.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>new_child</em>, <em>label=None</em>, <em>containment=True</em>, <em>replace=False</em>, <em>inherit_periodicity=True</em>, <em>reset_rigid_ids=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a part to the Compound.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>This does not necessarily add the part to self.children but may
instead be used to add a reference to the part to self.labels. See
‘containment’ argument.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_child</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list-like of mb.Compound</span></dt>
<dd><p class="first last">The object(s) to be added to this Compound.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">A descriptive string for the part.</p>
</dd>
<dt><strong>containment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Add the part to self.children.</p>
</dd>
<dt><strong>replace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Replace the label if it already exists.</p>
</dd>
<dt><strong>inherit_periodicity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Replace the periodicity of self with the periodicity of the
Compound being added</p>
</dd>
<dt><strong>reset_rigid_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">If the Compound to be added contains rigid bodies, reset the
rigid_ids such that values remain distinct from rigid_ids
already present in <cite>self</cite>. Can be set to False if attempting
to add Compounds to an existing rigid body.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.add_bond">
<code class="descname">add_bond</code><span class="sig-paren">(</span><em>particle_pair</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.add_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a bond between two Particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>particle_pair</strong> <span class="classifier-delimiter">:</span> <span class="classifier">indexable object, length=2, dtype=mb.Compound</span></dt>
<dd><p class="first last">The pair of Particles to add a bond between</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.all_ports">
<code class="descname">all_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.all_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Ports referenced by this Compound and its successors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all Ports referenced by this Compound and its successors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.ancestors">
<code class="descname">ancestors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.ancestors" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all ancestors of the Compound recursively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Compound above self in the hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.available_ports">
<code class="descname">available_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.available_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all unoccupied Ports referenced by this Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all unoccupied ports referenced by the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.bonds">
<code class="descname">bonds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all bonds in the Compound and sub-Compounds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple of mb.Compound</strong></dt>
<dd><p class="first last">The next bond in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bond_graph.edges_iter</span></code></dt>
<dd>Iterates over all edges in a BondGraph</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.boundingbox">
<code class="descname">boundingbox</code><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.boundingbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bounding box of the compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Box</strong></dt>
<dd><p class="first last">The bounding box for this Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.center">
<code class="descname">center</code><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.center" title="Permalink to this definition">¶</a></dt>
<dd><p>The cartesian center of the Compound based on its Particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>np.ndarray, shape=(3,), dtype=float</strong></dt>
<dd><p class="first last">The cartesian center of the Compound based on its Particles</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.contains_rigid">
<code class="descname">contains_rigid</code><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.contains_rigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the Compound contains rigid bodies</p>
<p>If the Compound contains any particle with a rigid_id != None
then contains_rigid will return True. If the Compound has no
children (i.e. the Compound resides at the bottom of the containment
hierarchy) then contains_rigid will return False.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bool</strong></dt>
<dd><p class="first last">True if the Compound contains any particle with a rigid_id != None</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The private variable ‘_check_if_contains_rigid_bodies’ is used to help
cache the status of ‘contains_rigid’. If ‘_check_if_contains_rigid_bodies’
is False, then the rigid body containment of the Compound has not changed,
and the particle tree is not traversed, boosting performance.</p>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.energy_minimize">
<code class="descname">energy_minimize</code><span class="sig-paren">(</span><em>forcefield='UFF'</em>, <em>steps=1000</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.energy_minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an energy minimization on a Compound</p>
<p>Default beahvior utilizes Open Babel (<a class="reference external" href="http://openbabel.org/docs/dev/">http://openbabel.org/docs/dev/</a>)
to perform an energy minimization/geometry optimization on a
Compound by applying a generic force field</p>
<p>Can also utilize OpenMM (<a class="reference external" href="http://openmm.org/">http://openmm.org/</a>) to energy minimize
after atomtyping a Compound using
Foyer (<a class="reference external" href="https://github.com/mosdef-hub/foyer">https://github.com/mosdef-hub/foyer</a>) to apply a forcefield
XML file that contains valid SMARTS strings.</p>
<p>This function is primarily intended to be used on smaller components,
with sizes on the order of 10’s to 100’s of particles, as the energy
minimization scales poorly with the number of particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>steps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1000</span></dt>
<dd><p class="first last">The number of optimization iterations</p>
</dd>
<dt><strong>forcefield</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’UFF’</span></dt>
<dd><p class="first last">The generic force field to apply to the Compound for minimization.
Valid options are ‘MMFF94’, ‘MMFF94s’, ‘’UFF’, ‘GAFF’, and ‘Ghemical’.
Please refer to the Open Babel documentation (<a class="reference external" href="http://open-babel">http://open-babel</a>.
readthedocs.io/en/latest/Forcefields/Overview.html) when considering
your choice of force field.
Utilizing OpenMM for energy minimization requires a forcefield
XML file with valid SMARTS strings. Please refer to (<a class="reference external" href="http://docs">http://docs</a>.
openmm.org/7.0.0/userguide/application.html#creating-force-fields)
for more information.</p>
</dd>
<dt><strong>Keyword Arguments</strong></dt>
<dd></dd>
<dt><strong>————</strong></dt>
<dd></dd>
<dt><strong>algorithm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’cg’</span></dt>
<dd><p class="first last">The energy minimization algorithm.  Valid options are ‘steep’,
‘cg’, and ‘md’, corresponding to steepest descent, conjugate
gradient, and equilibrium molecular dynamics respectively.
For _energy_minimize_openbabel</p>
</dd>
<dt><strong>scale_bonds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the bond force constant (1 is completely on).
For _energy_minimize_openmm</p>
</dd>
<dt><strong>scale_angles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the angle force constant (1 is completely on)
For _energy_minimize_openmm</p>
</dd>
<dt><strong>scale_torsions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the torsional force constants (1 is completely on)
For _energy_minimize_openmm
Note: Only Ryckaert-Bellemans style torsions are currently supported</p>
</dd>
<dt><strong>scale_nonbonded</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales epsilon (1 is completely on)
For _energy_minimize_openmm</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>If using _energy_minimize_openmm(), please cite:
.. [R3dfbea0e586c-1] P. Eastman, M. S. Friedrichs, J. D. Chodera, R. J. Radmer,</p>
<blockquote>
<div>C. M. Bruns, J. P. Ku, K. A. Beauchamp, T. J. Lane,
L.-P. Wang, D. Shukla, T. Tye, M. Houston, T. Stich,
C. Klein, M. R. Shirts, and V. S. Pande.
“OpenMM 4: A Reusable, Extensible, Hardware Independent
Library for High Performance Molecular Simulation.”
J. Chem. Theor. Comput. 9(1): 461-469. (2013).</div></blockquote>
<p>If using _energy_minimize_openbabel(), please cite:
.. [R3dfbea0e586c-1] O’Boyle, N.M.; Banck, M.; James, C.A.; Morley, C.;</p>
<blockquote>
<div>Vandermeersch, T.; Hutchison, G.R. “Open Babel: An open
chemical toolbox.” (2011) J. Cheminf. 3, 33</div></blockquote>
<table class="docutils citation" frame="void" id="r3dfbea0e586c-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[2]</a></td><td>Open Babel, version X.X.X <a class="reference external" href="http://openbabel.org">http://openbabel.org</a>, (installed
Month Year)</td></tr>
</tbody>
</table>
<p>If using the ‘MMFF94’ force field please also cite the following:
.. [R3dfbea0e586c-3] T.A. Halgren, “Merck molecular force field. I. Basis, form,</p>
<blockquote>
<div>scope, parameterization, and performance of MMFF94.” (1996)
J. Comput. Chem. 17, 490-519</div></blockquote>
<table class="docutils citation" frame="void" id="r3dfbea0e586c-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id29">[4]</a></td><td>T.A. Halgren, “Merck molecular force field. II. MMFF94 van der
Waals and electrostatic parameters for intermolecular
interactions.” (1996) J. Comput. Chem. 17, 520-552</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r3dfbea0e586c-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id30">[5]</a></td><td>T.A. Halgren, “Merck molecular force field. III. Molecular
geometries and vibrational frequencies for MMFF94.” (1996)
J. Comput. Chem. 17, 553-586</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r3dfbea0e586c-6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id31">[6]</a></td><td>T.A. Halgren and R.B. Nachbar, “Merck molecular force field.
IV. Conformational energies and geometries for MMFF94.” (1996)
J. Comput. Chem. 17, 587-615</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r3dfbea0e586c-7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id32">[7]</a></td><td>T.A. Halgren, “Merck molecular force field. V. Extension of
MMFF94 using experimental data, additional computational data,
and empirical rules.” (1996) J. Comput. Chem. 17, 616-641</td></tr>
</tbody>
</table>
<p>If using the ‘MMFF94s’ force field please cite the above along with:
.. [R3dfbea0e586c-8] T.A. Halgren, “MMFF VI. MMFF94s option for energy minimization</p>
<blockquote>
<div>studies.” (1999) J. Comput. Chem. 20, 720-729</div></blockquote>
<p>If using the ‘UFF’ force field please cite the following:
.. [R3dfbea0e586c-3] Rappe, A.K., Casewit, C.J., Colwell, K.S., Goddard, W.A. III,</p>
<blockquote>
<div>Skiff, W.M. “UFF, a full periodic table force field for
molecular mechanics and molecular dynamics simulations.” (1992)
J. Am. Chem. Soc. 114, 10024-10039</div></blockquote>
<p>If using the ‘GAFF’ force field please cite the following:
.. [R3dfbea0e586c-3] Wang, J., Wolf, R.M., Caldwell, J.W., Kollman, P.A., Case, D.A.</p>
<blockquote>
<div>“Development and testing of a general AMBER force field” (2004)
J. Comput. Chem. 25, 1157-1174</div></blockquote>
<p>If using the ‘Ghemical’ force field please cite the following:
.. [R3dfbea0e586c-3] T. Hassinen and M. Perakyla, “New energy terms for reduced</p>
<blockquote>
<div>protein models implemented in an off-lattice force field” (2001)
J. Comput. Chem. 22, 1229-1242</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.from_parmed">
<code class="descname">from_parmed</code><span class="sig-paren">(</span><em>structure</em>, <em>coords_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.from_parmed" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract atoms and bonds from a pmd.Structure.</p>
<p>Will create sub-compounds for every chain if there is more than one
and sub-sub-compounds for every residue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>structure</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pmd.Structure</span></dt>
<dd><p class="first last">The structure to load.</p>
</dd>
<dt><strong>coords_only</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set preexisting atoms in compound to coordinates given by structure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.from_trajectory">
<code class="descname">from_trajectory</code><span class="sig-paren">(</span><em>traj</em>, <em>frame=-1</em>, <em>coords_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.from_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract atoms and bonds from a md.Trajectory.</p>
<p>Will create sub-compounds for every chain if there is more than one
and sub-sub-compounds for every residue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>traj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mdtraj.Trajectory</span></dt>
<dd><p class="first last">The trajectory to load.</p>
</dd>
<dt><strong>frame</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=-1 (last)</span></dt>
<dd><p class="first last">The frame to take coordinates from.</p>
</dd>
<dt><strong>coords_only</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Only read coordinate information</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.generate_bonds">
<code class="descname">generate_bonds</code><span class="sig-paren">(</span><em>name_a</em>, <em>name_b</em>, <em>dmin</em>, <em>dmax</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.generate_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Bonds between all pairs of types a/b within [dmin, dmax].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>name_a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of one of the Particles to be in each bond</p>
</dd>
<dt><strong>name_b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of the other Particle to be in each bond</p>
</dd>
<dt><strong>dmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum distance between Particles for considering a bond</p>
</dd>
<dt><strong>dmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum distance between Particles for considering a bond</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.label_rigid_bodies">
<code class="descname">label_rigid_bodies</code><span class="sig-paren">(</span><em>discrete_bodies=None</em>, <em>rigid_particles=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.label_rigid_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Designate which Compounds should be treated as rigid bodies</p>
<p>If no arguments are provided, this function will treat the compound
as a single rigid body by providing all particles in <cite>self</cite> with the
same rigid_id. If <cite>discrete_bodies</cite> is not None, each instance of
a Compound with a name found in <cite>discrete_bodies</cite> will be treated as a
unique rigid body. If <cite>rigid_particles</cite> is not None, only Particles
(Compounds at the bottom of the containment hierarchy) matching this name
will be considered part of the rigid body.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>discrete_bodies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional, default=None</span></dt>
<dd><p class="first last">Name(s) of Compound instances to be treated as unique rigid bodies.
Compound instances matching this (these) name(s) will be provided
with unique rigid_ids</p>
</dd>
<dt><strong>rigid_particles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional, default=None</span></dt>
<dd><p class="first last">Name(s) of Compound instances at the bottom of the containment
hierarchy (Particles) to be included in rigid bodies. Only Particles
matching this (these) name(s) will have their rigid_ids altered to
match the rigid body number.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Creating a rigid benzene</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">()</span>
</pre></div>
</div>
<p>Creating a semi-rigid benzene, where only the carbons are treated as
a rigid body</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">rigid_particles</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a box of rigid benzenes, where each benzene has a unique rigid
body ID.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Benzene&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">fill_box</span><span class="p">(</span><span class="n">benzene</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">n_compounds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">box</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">distinct_bodies</span><span class="o">=</span><span class="s1">&#39;Benzene&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a box of semi-rigid benzenes, where each benzene has a unique
rigid body ID and only the carbon portion is treated as rigid.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Benzene&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">fill_box</span><span class="p">(</span><span class="n">benzene</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">n_compounds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">box</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">distinct_bodies</span><span class="o">=</span><span class="s1">&#39;Benzene&#39;</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">rigid_particles</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.max_rigid_id">
<code class="descname">max_rigid_id</code><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.max_rigid_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum rigid body ID contained in the Compound.</p>
<p>This is usually used by compound.root to determine the maximum
rigid_id in the containment hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int or None</strong></dt>
<dd><p class="first last">The maximum rigid body ID contained in the Compound. If no
rigid body IDs are found, None is returned</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.min_periodic_distance">
<code class="descname">min_periodic_distance</code><span class="sig-paren">(</span><em>xyz0</em>, <em>xyz1</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.min_periodic_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorized distance calculation considering minimum image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>xyz0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">Coordinates of first point</p>
</dd>
<dt><strong>xyz1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">Coordinates of second point</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>float</strong></dt>
<dd><p class="first last">Vectorized distance between the two points following minimum
image convention</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.n_bonds">
<code class="descname">n_bonds</code><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.n_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of bonds in the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int</strong></dt>
<dd><p class="first last">The number of bonds in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.n_particles">
<code class="descname">n_particles</code><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.n_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of Particles in the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int</strong></dt>
<dd><p class="first last">The number of Particles in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.particles">
<code class="descname">particles</code><span class="sig-paren">(</span><em>include_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Particles of the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>include_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Include port particles</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.particles_by_name">
<code class="descname">particles_by_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.particles_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Particles of the Compound with a specific name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Only particles with this name are returned</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle in the Compound with the user-specified name</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.particles_in_range">
<code class="descname">particles_in_range</code><span class="sig-paren">(</span><em>compound</em>, <em>dmax</em>, <em>max_particles=20</em>, <em>particle_kdtree=None</em>, <em>particle_array=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.particles_in_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Find particles within a specified range of another particle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>compound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd><p class="first last">Reference particle to find other particles in range of</p>
</dd>
<dt><strong>dmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum distance from ‘compound’ to look for Particles</p>
</dd>
<dt><strong>max_particles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=20</span></dt>
<dd><p class="first last">Maximum number of Particles to return</p>
</dd>
<dt><strong>particle_kdtree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.PeriodicCKDTree, optional</span></dt>
<dd><p class="first last">KD-tree for looking up nearest neighbors. If not provided, a KD-
tree will be generated from all Particles in self</p>
</dd>
<dt><strong>particle_array</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=mb.Compound, optional</span></dt>
<dd><p class="first last">Array of possible particles to consider for return. If not
provided, this defaults to all Particles in self</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>np.ndarray, shape=(n,), dtype=mb.Compound</strong></dt>
<dd><p class="first last">Particles in range of compound according to user-defined limits</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">periodic_kdtree.PerioidicCKDTree</span></code></dt>
<dd>mBuild implementation of kd-trees</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.spatial.ckdtree</span></code></dt>
<dd>Further details on kd-trees</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.referenced_ports">
<code class="descname">referenced_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.referenced_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Ports referenced by this Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all ports referenced by the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>objs_to_remove</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove children from the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>objs_to_remove</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list of mb.Compound</span></dt>
<dd><p class="first last">The Compound(s) to be removed from self</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.remove_bond">
<code class="descname">remove_bond</code><span class="sig-paren">(</span><em>particle_pair</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.remove_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a bond between a pair of Particles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>particle_pair</strong> <span class="classifier-delimiter">:</span> <span class="classifier">indexable object, length=2, dtype=mb.Compound</span></dt>
<dd><p class="first last">The pair of Particles to remove the bond between</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.rigid_particles">
<code class="descname">rigid_particles</code><span class="sig-paren">(</span><em>rigid_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.rigid_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all particles in rigid bodies.</p>
<p>If a rigid_id is specified, then this function will only yield particles
with a matching rigid_id.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rigid_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Include only particles with this rigid body ID</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next particle with a rigid_id that is not None, or the next
particle with a matching rigid_id if specified</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.root">
<code class="descname">root</code><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.root" title="Permalink to this definition">¶</a></dt>
<dd><p>The Compound at the top of self’s hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The Compound at the top of self’s hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>theta</em>, <em>around</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate Compound around an arbitrary vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The angle by which to rotate the Compound, in radians.</p>
</dd>
<dt><strong>around</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">The vector about which to rotate the Compound.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>show_ports=False</em>, <em>forcefield_name=None</em>, <em>forcefield_files=None</em>, <em>forcefield_debug=False</em>, <em>box=None</em>, <em>overwrite=False</em>, <em>residues=None</em>, <em>references_file=None</em>, <em>combining_rule='lorentz'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the Compound to a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Filesystem path in which to save the trajectory. The extension or
prefix will be parsed and control the format. Supported
extensions are: ‘hoomdxml’, ‘gsd’, ‘gro’, ‘top’, ‘lammps’, ‘lmp’</p>
</dd>
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Save ports contained within the compound.</p>
</dd>
<dt><strong>forcefield_files</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Apply a forcefield to the output file using a forcefield provided
by the <cite>foyer</cite> package.</p>
</dd>
<dt><strong>forcefield_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Apply a named forcefield to the output file using the <cite>foyer</cite>
package, e.g. ‘oplsaa’. Forcefields listed here:
<a class="reference external" href="https://github.com/mosdef-hub/foyer/tree/master/foyer/forcefields">https://github.com/mosdef-hub/foyer/tree/master/foyer/forcefields</a></p>
</dd>
<dt><strong>forcefield_debug</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Choose level of verbosity when applying a forcefield through <cite>foyer</cite>.
Specifically, when missing atom types in the forcefield xml file,
determine if the warning is condensed or verbose.</p>
</dd>
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be written to the output file. If ‘None’, a
bounding box is used with 0.25nm buffers at each face to avoid
overlapping atoms.</p>
</dd>
<dt><strong>overwrite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Overwrite if the filename already exists</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>references_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Specify a filename to write references for the forcefield that is
to be applied. References are written in BiBTeX format.</p>
</dd>
<dt><strong>combining_rule</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’lorentz’</span></dt>
<dd><p class="first last">Specify the combining rule for nonbonded interactions. Only relevant
when the <cite>foyer</cite> package is used to apply a forcefield. Valid
options are ‘lorentz’ and ‘geometric’, specifying Lorentz-Berthelot
and geometric combining rules respectively.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>ref_distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting distance values to reduced units.</p>
</dd>
<dt><strong>ref_energy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting energy values to reduced units.</p>
</dd>
<dt><strong>ref_mass</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting mass values to reduced units.</p>
</dd>
<dt><strong>atom_style: str, default=’full’</strong></dt>
<dd><p class="first last">Defines the style of atoms to be saved in a LAMMPS data file. The following atom
styles are currently supported: ‘full’, ‘atomic’, ‘charge’, ‘molecular’
see <a class="reference external" href="http://lammps.sandia.gov/doc/atom_style.html">http://lammps.sandia.gov/doc/atom_style.html</a> for more
information on atom styles.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.gsdwrite.write_gsd</span></code></dt>
<dd>Write to GSD format</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.hoomdxml.write_hoomdxml</span></code></dt>
<dd>Write to Hoomd XML format</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.lammpsdata.write_lammpsdata</span></code></dt>
<dd>Write to LAMMPS data format</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.spin">
<code class="descname">spin</code><span class="sig-paren">(</span><em>theta</em>, <em>around</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate Compound in place around an arbitrary vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The angle by which to rotate the Compound, in radians.</p>
</dd>
<dt><strong>around</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">The axis about which to spin the Compound.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.successors">
<code class="descname">successors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield Compounds below self in the hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle below self in the hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.to_intermol">
<code class="descname">to_intermol</code><span class="sig-paren">(</span><em>molecule_types=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.to_intermol" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an InterMol system from a Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>molecule_types</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or tuple of subclasses of Compound</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>intermol_system</strong> <span class="classifier-delimiter">:</span> <span class="classifier">intermol.system.System</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.to_parmed">
<code class="descname">to_parmed</code><span class="sig-paren">(</span><em>box=None</em>, <em>title=''</em>, <em>residues=None</em>, <em>show_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.to_parmed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a ParmEd Structure from a Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be used when converting to a <cite>Structure</cite>.
If ‘None’, a bounding box is used with 0.25nm buffers at
each face to avoid overlapping atoms, unless <cite>self.periodicity</cite>
is not None, in which case those values are used for the
box lengths.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=self.name</span></dt>
<dd><p class="first last">Title/name of the ParmEd Structure</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional, default=False</span></dt>
<dd><p class="first last">Include all port atoms when converting to a <cite>Structure</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>parmed.structure.Structure</strong></dt>
<dd><p class="first last">ParmEd Structure object converted from self</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">parmed.structure.Structure</span></code></dt>
<dd>Details on the ParmEd Structure object</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.to_trajectory">
<code class="descname">to_trajectory</code><span class="sig-paren">(</span><em>show_ports=False</em>, <em>chains=None</em>, <em>residues=None</em>, <em>box=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.to_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to an md.Trajectory and flatten the compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Include all port atoms when converting to trajectory.</p>
</dd>
<dt><strong>chains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list of mb.Compound</span></dt>
<dd><p class="first last">Chain types to add to the topology</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be used when converting to a <cite>Trajectory</cite>.
If ‘None’, a bounding box is used with a 0.5nm buffer in each
dimension. to avoid overlapping atoms, unless <cite>self.periodicity</cite>
is not None, in which case those values are used for the
box lengths.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trajectory</strong> <span class="classifier-delimiter">:</span> <span class="classifier">md.Trajectory</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_to_topology</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>by</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the Compound by a vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.translate_to">
<code class="descname">translate_to</code><span class="sig-paren">(</span><em>pos</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.translate_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the Compound to a specific position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=3(,), dtype=float</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.unlabel_rigid_bodies">
<code class="descname">unlabel_rigid_bodies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.unlabel_rigid_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all rigid body labels from the Compound</p>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.update_coordinates">
<code class="descname">update_coordinates</code><span class="sig-paren">(</span><em>filename</em>, <em>update_port_locations=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.update_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the coordinates of this Compound from a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of file from which to load coordinates. Supported file types
are the same as those supported by load()</p>
</dd>
<dt><strong>update_port_locations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Update the locations of Ports so that they are shifted along with
their anchor particles.  Note: This conserves the location of
Ports with respect to the anchor Particle, but does not conserve
the orientation of Ports with respect to the molecule as a whole.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">load</span></code></dt>
<dd>Load coordinates from a file</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.visualize">
<code class="descname">visualize</code><span class="sig-paren">(</span><em>show_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.visualize" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the Compound using nglview.</p>
<p>Allows for visualization of a Compound within a Jupyter Notebook.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Visualize Ports in addition to Particles</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.xyz">
<code class="descname">xyz</code><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all particle coordinates in this compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 3), dtype=float</span></dt>
<dd><p class="first last">Array with the positions of all particles.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.tiled_compound.TiledCompound.xyz_with_ports">
<code class="descname">xyz_with_ports</code><a class="headerlink" href="#mbuild.recipes.tiled_compound.TiledCompound.xyz_with_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all particle coordinates in this compound including ports.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 3), dtype=float</span></dt>
<dd><p class="first last">Array with the positions of all particles and ports.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="silica-interface">
<h2>Silica Interface<a class="headerlink" href="#silica-interface" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="mbuild.recipes.silica_interface.SilicaInterface">
<em class="property">class </em><code class="descclassname">mbuild.recipes.silica_interface.</code><code class="descname">SilicaInterface</code><span class="sig-paren">(</span><em>bulk_silica</em>, <em>tile_x=1</em>, <em>tile_y=1</em>, <em>thickness=1.0</em>, <em>seed=12345</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mbuild/recipes/silica_interface.html#SilicaInterface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface" title="Permalink to this definition">¶</a></dt>
<dd><p>A recipe for creating an interface from bulk silica.</p>
<p>Carves silica interface from bulk, adjusts to a reactive
surface site density of 5.0 sites/nm^2 (agreeing with experimental
results, see Zhuravlev 2000) by creating Si-O-Si bridges, and
yields a 2:1 Si:O ratio (excluding the reactive surface sites).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bulk_silica</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd><p class="first last">Bulk silica from which to cleave an interface</p>
</dd>
<dt><strong>tile_x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1</span></dt>
<dd><p class="first last">Number of times to replicate bulk silica in x-direction</p>
</dd>
<dt><strong>tile_y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1</span></dt>
<dd><p class="first last">Number of times to replicate bulk silica in y-direction</p>
</dd>
<dt><strong>thickness</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Thickness of the slab to carve from the silica bulk. (in nm; not
including oxygen layers on the top and bottom of the surface)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rf610960ab19e-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id37">[1]</a></td><td>Hartkamp, R., Siboulet, B., Dufreche, J.-F., Boasne, B.
“Ion-specific adsorption and electroosmosis in charged
amorphous porous silica.” (2015) Phys. Chem. Chem. Phys.
17, 24683-24695</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rf610960ab19e-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id38">[2]</a></td><td>L.T. Zhuravlev, “The surface chemistry of amorphous silica.
Zhuravlev model.” (2000) Colloids Surf., A. 10, 1-38</td></tr>
</tbody>
</table>
<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>new_child</em>, <em>label=None</em>, <em>containment=True</em>, <em>replace=False</em>, <em>inherit_periodicity=True</em>, <em>reset_rigid_ids=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a part to the Compound.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>This does not necessarily add the part to self.children but may
instead be used to add a reference to the part to self.labels. See
‘containment’ argument.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_child</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list-like of mb.Compound</span></dt>
<dd><p class="first last">The object(s) to be added to this Compound.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">A descriptive string for the part.</p>
</dd>
<dt><strong>containment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Add the part to self.children.</p>
</dd>
<dt><strong>replace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Replace the label if it already exists.</p>
</dd>
<dt><strong>inherit_periodicity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Replace the periodicity of self with the periodicity of the
Compound being added</p>
</dd>
<dt><strong>reset_rigid_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">If the Compound to be added contains rigid bodies, reset the
rigid_ids such that values remain distinct from rigid_ids
already present in <cite>self</cite>. Can be set to False if attempting
to add Compounds to an existing rigid body.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.add_bond">
<code class="descname">add_bond</code><span class="sig-paren">(</span><em>particle_pair</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.add_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a bond between two Particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>particle_pair</strong> <span class="classifier-delimiter">:</span> <span class="classifier">indexable object, length=2, dtype=mb.Compound</span></dt>
<dd><p class="first last">The pair of Particles to add a bond between</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.all_ports">
<code class="descname">all_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.all_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Ports referenced by this Compound and its successors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all Ports referenced by this Compound and its successors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.ancestors">
<code class="descname">ancestors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.ancestors" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all ancestors of the Compound recursively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Compound above self in the hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.available_ports">
<code class="descname">available_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.available_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all unoccupied Ports referenced by this Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all unoccupied ports referenced by the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.bonds">
<code class="descname">bonds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all bonds in the Compound and sub-Compounds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple of mb.Compound</strong></dt>
<dd><p class="first last">The next bond in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bond_graph.edges_iter</span></code></dt>
<dd>Iterates over all edges in a BondGraph</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.boundingbox">
<code class="descname">boundingbox</code><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.boundingbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bounding box of the compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Box</strong></dt>
<dd><p class="first last">The bounding box for this Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.center">
<code class="descname">center</code><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.center" title="Permalink to this definition">¶</a></dt>
<dd><p>The cartesian center of the Compound based on its Particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>np.ndarray, shape=(3,), dtype=float</strong></dt>
<dd><p class="first last">The cartesian center of the Compound based on its Particles</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.contains_rigid">
<code class="descname">contains_rigid</code><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.contains_rigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the Compound contains rigid bodies</p>
<p>If the Compound contains any particle with a rigid_id != None
then contains_rigid will return True. If the Compound has no
children (i.e. the Compound resides at the bottom of the containment
hierarchy) then contains_rigid will return False.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bool</strong></dt>
<dd><p class="first last">True if the Compound contains any particle with a rigid_id != None</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The private variable ‘_check_if_contains_rigid_bodies’ is used to help
cache the status of ‘contains_rigid’. If ‘_check_if_contains_rigid_bodies’
is False, then the rigid body containment of the Compound has not changed,
and the particle tree is not traversed, boosting performance.</p>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.energy_minimize">
<code class="descname">energy_minimize</code><span class="sig-paren">(</span><em>forcefield='UFF'</em>, <em>steps=1000</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.energy_minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an energy minimization on a Compound</p>
<p>Default beahvior utilizes Open Babel (<a class="reference external" href="http://openbabel.org/docs/dev/">http://openbabel.org/docs/dev/</a>)
to perform an energy minimization/geometry optimization on a
Compound by applying a generic force field</p>
<p>Can also utilize OpenMM (<a class="reference external" href="http://openmm.org/">http://openmm.org/</a>) to energy minimize
after atomtyping a Compound using
Foyer (<a class="reference external" href="https://github.com/mosdef-hub/foyer">https://github.com/mosdef-hub/foyer</a>) to apply a forcefield
XML file that contains valid SMARTS strings.</p>
<p>This function is primarily intended to be used on smaller components,
with sizes on the order of 10’s to 100’s of particles, as the energy
minimization scales poorly with the number of particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>steps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1000</span></dt>
<dd><p class="first last">The number of optimization iterations</p>
</dd>
<dt><strong>forcefield</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’UFF’</span></dt>
<dd><p class="first last">The generic force field to apply to the Compound for minimization.
Valid options are ‘MMFF94’, ‘MMFF94s’, ‘’UFF’, ‘GAFF’, and ‘Ghemical’.
Please refer to the Open Babel documentation (<a class="reference external" href="http://open-babel">http://open-babel</a>.
readthedocs.io/en/latest/Forcefields/Overview.html) when considering
your choice of force field.
Utilizing OpenMM for energy minimization requires a forcefield
XML file with valid SMARTS strings. Please refer to (<a class="reference external" href="http://docs">http://docs</a>.
openmm.org/7.0.0/userguide/application.html#creating-force-fields)
for more information.</p>
</dd>
<dt><strong>Keyword Arguments</strong></dt>
<dd></dd>
<dt><strong>————</strong></dt>
<dd></dd>
<dt><strong>algorithm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’cg’</span></dt>
<dd><p class="first last">The energy minimization algorithm.  Valid options are ‘steep’,
‘cg’, and ‘md’, corresponding to steepest descent, conjugate
gradient, and equilibrium molecular dynamics respectively.
For _energy_minimize_openbabel</p>
</dd>
<dt><strong>scale_bonds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the bond force constant (1 is completely on).
For _energy_minimize_openmm</p>
</dd>
<dt><strong>scale_angles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the angle force constant (1 is completely on)
For _energy_minimize_openmm</p>
</dd>
<dt><strong>scale_torsions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales the torsional force constants (1 is completely on)
For _energy_minimize_openmm
Note: Only Ryckaert-Bellemans style torsions are currently supported</p>
</dd>
<dt><strong>scale_nonbonded</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1</span></dt>
<dd><p class="first last">Scales epsilon (1 is completely on)
For _energy_minimize_openmm</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>If using _energy_minimize_openmm(), please cite:
.. [Rd802fe3f8fe7-1] P. Eastman, M. S. Friedrichs, J. D. Chodera, R. J. Radmer,</p>
<blockquote>
<div>C. M. Bruns, J. P. Ku, K. A. Beauchamp, T. J. Lane,
L.-P. Wang, D. Shukla, T. Tye, M. Houston, T. Stich,
C. Klein, M. R. Shirts, and V. S. Pande.
“OpenMM 4: A Reusable, Extensible, Hardware Independent
Library for High Performance Molecular Simulation.”
J. Chem. Theor. Comput. 9(1): 461-469. (2013).</div></blockquote>
<p>If using _energy_minimize_openbabel(), please cite:
.. [Rd802fe3f8fe7-1] O’Boyle, N.M.; Banck, M.; James, C.A.; Morley, C.;</p>
<blockquote>
<div>Vandermeersch, T.; Hutchison, G.R. “Open Babel: An open
chemical toolbox.” (2011) J. Cheminf. 3, 33</div></blockquote>
<table class="docutils citation" frame="void" id="rd802fe3f8fe7-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id41">[2]</a></td><td>Open Babel, version X.X.X <a class="reference external" href="http://openbabel.org">http://openbabel.org</a>, (installed
Month Year)</td></tr>
</tbody>
</table>
<p>If using the ‘MMFF94’ force field please also cite the following:
.. [Rd802fe3f8fe7-3] T.A. Halgren, “Merck molecular force field. I. Basis, form,</p>
<blockquote>
<div>scope, parameterization, and performance of MMFF94.” (1996)
J. Comput. Chem. 17, 490-519</div></blockquote>
<table class="docutils citation" frame="void" id="rd802fe3f8fe7-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id43">[4]</a></td><td>T.A. Halgren, “Merck molecular force field. II. MMFF94 van der
Waals and electrostatic parameters for intermolecular
interactions.” (1996) J. Comput. Chem. 17, 520-552</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rd802fe3f8fe7-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id44">[5]</a></td><td>T.A. Halgren, “Merck molecular force field. III. Molecular
geometries and vibrational frequencies for MMFF94.” (1996)
J. Comput. Chem. 17, 553-586</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rd802fe3f8fe7-6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id45">[6]</a></td><td>T.A. Halgren and R.B. Nachbar, “Merck molecular force field.
IV. Conformational energies and geometries for MMFF94.” (1996)
J. Comput. Chem. 17, 587-615</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rd802fe3f8fe7-7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id46">[7]</a></td><td>T.A. Halgren, “Merck molecular force field. V. Extension of
MMFF94 using experimental data, additional computational data,
and empirical rules.” (1996) J. Comput. Chem. 17, 616-641</td></tr>
</tbody>
</table>
<p>If using the ‘MMFF94s’ force field please cite the above along with:
.. [Rd802fe3f8fe7-8] T.A. Halgren, “MMFF VI. MMFF94s option for energy minimization</p>
<blockquote>
<div>studies.” (1999) J. Comput. Chem. 20, 720-729</div></blockquote>
<p>If using the ‘UFF’ force field please cite the following:
.. [Rd802fe3f8fe7-3] Rappe, A.K., Casewit, C.J., Colwell, K.S., Goddard, W.A. III,</p>
<blockquote>
<div>Skiff, W.M. “UFF, a full periodic table force field for
molecular mechanics and molecular dynamics simulations.” (1992)
J. Am. Chem. Soc. 114, 10024-10039</div></blockquote>
<p>If using the ‘GAFF’ force field please cite the following:
.. [Rd802fe3f8fe7-3] Wang, J., Wolf, R.M., Caldwell, J.W., Kollman, P.A., Case, D.A.</p>
<blockquote>
<div>“Development and testing of a general AMBER force field” (2004)
J. Comput. Chem. 25, 1157-1174</div></blockquote>
<p>If using the ‘Ghemical’ force field please cite the following:
.. [Rd802fe3f8fe7-3] T. Hassinen and M. Perakyla, “New energy terms for reduced</p>
<blockquote>
<div>protein models implemented in an off-lattice force field” (2001)
J. Comput. Chem. 22, 1229-1242</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.from_parmed">
<code class="descname">from_parmed</code><span class="sig-paren">(</span><em>structure</em>, <em>coords_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.from_parmed" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract atoms and bonds from a pmd.Structure.</p>
<p>Will create sub-compounds for every chain if there is more than one
and sub-sub-compounds for every residue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>structure</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pmd.Structure</span></dt>
<dd><p class="first last">The structure to load.</p>
</dd>
<dt><strong>coords_only</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set preexisting atoms in compound to coordinates given by structure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.from_trajectory">
<code class="descname">from_trajectory</code><span class="sig-paren">(</span><em>traj</em>, <em>frame=-1</em>, <em>coords_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.from_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract atoms and bonds from a md.Trajectory.</p>
<p>Will create sub-compounds for every chain if there is more than one
and sub-sub-compounds for every residue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>traj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mdtraj.Trajectory</span></dt>
<dd><p class="first last">The trajectory to load.</p>
</dd>
<dt><strong>frame</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=-1 (last)</span></dt>
<dd><p class="first last">The frame to take coordinates from.</p>
</dd>
<dt><strong>coords_only</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Only read coordinate information</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.generate_bonds">
<code class="descname">generate_bonds</code><span class="sig-paren">(</span><em>name_a</em>, <em>name_b</em>, <em>dmin</em>, <em>dmax</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.generate_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Bonds between all pairs of types a/b within [dmin, dmax].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>name_a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of one of the Particles to be in each bond</p>
</dd>
<dt><strong>name_b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of the other Particle to be in each bond</p>
</dd>
<dt><strong>dmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum distance between Particles for considering a bond</p>
</dd>
<dt><strong>dmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum distance between Particles for considering a bond</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.label_rigid_bodies">
<code class="descname">label_rigid_bodies</code><span class="sig-paren">(</span><em>discrete_bodies=None</em>, <em>rigid_particles=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.label_rigid_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Designate which Compounds should be treated as rigid bodies</p>
<p>If no arguments are provided, this function will treat the compound
as a single rigid body by providing all particles in <cite>self</cite> with the
same rigid_id. If <cite>discrete_bodies</cite> is not None, each instance of
a Compound with a name found in <cite>discrete_bodies</cite> will be treated as a
unique rigid body. If <cite>rigid_particles</cite> is not None, only Particles
(Compounds at the bottom of the containment hierarchy) matching this name
will be considered part of the rigid body.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>discrete_bodies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional, default=None</span></dt>
<dd><p class="first last">Name(s) of Compound instances to be treated as unique rigid bodies.
Compound instances matching this (these) name(s) will be provided
with unique rigid_ids</p>
</dd>
<dt><strong>rigid_particles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional, default=None</span></dt>
<dd><p class="first last">Name(s) of Compound instances at the bottom of the containment
hierarchy (Particles) to be included in rigid bodies. Only Particles
matching this (these) name(s) will have their rigid_ids altered to
match the rigid body number.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Creating a rigid benzene</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">()</span>
</pre></div>
</div>
<p>Creating a semi-rigid benzene, where only the carbons are treated as
a rigid body</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">rigid_particles</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a box of rigid benzenes, where each benzene has a unique rigid
body ID.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Benzene&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">fill_box</span><span class="p">(</span><span class="n">benzene</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">n_compounds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">box</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">distinct_bodies</span><span class="o">=</span><span class="s1">&#39;Benzene&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a box of semi-rigid benzenes, where each benzene has a unique
rigid body ID and only the carbon portion is treated as rigid.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;benzene.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">benzene</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Benzene&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">fill_box</span><span class="p">(</span><span class="n">benzene</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">n_compounds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="n">box</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filled</span><span class="o">.</span><span class="n">label_rigid_bodies</span><span class="p">(</span><span class="n">distinct_bodies</span><span class="o">=</span><span class="s1">&#39;Benzene&#39;</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">rigid_particles</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.max_rigid_id">
<code class="descname">max_rigid_id</code><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.max_rigid_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum rigid body ID contained in the Compound.</p>
<p>This is usually used by compound.root to determine the maximum
rigid_id in the containment hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int or None</strong></dt>
<dd><p class="first last">The maximum rigid body ID contained in the Compound. If no
rigid body IDs are found, None is returned</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.min_periodic_distance">
<code class="descname">min_periodic_distance</code><span class="sig-paren">(</span><em>xyz0</em>, <em>xyz1</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.min_periodic_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorized distance calculation considering minimum image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>xyz0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">Coordinates of first point</p>
</dd>
<dt><strong>xyz1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">Coordinates of second point</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>float</strong></dt>
<dd><p class="first last">Vectorized distance between the two points following minimum
image convention</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.n_bonds">
<code class="descname">n_bonds</code><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.n_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of bonds in the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int</strong></dt>
<dd><p class="first last">The number of bonds in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.n_particles">
<code class="descname">n_particles</code><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.n_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of Particles in the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int</strong></dt>
<dd><p class="first last">The number of Particles in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.particles">
<code class="descname">particles</code><span class="sig-paren">(</span><em>include_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Particles of the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>include_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Include port particles</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle in the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.particles_by_name">
<code class="descname">particles_by_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.particles_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Particles of the Compound with a specific name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Only particles with this name are returned</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle in the Compound with the user-specified name</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.particles_in_range">
<code class="descname">particles_in_range</code><span class="sig-paren">(</span><em>compound</em>, <em>dmax</em>, <em>max_particles=20</em>, <em>particle_kdtree=None</em>, <em>particle_array=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.particles_in_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Find particles within a specified range of another particle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>compound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd><p class="first last">Reference particle to find other particles in range of</p>
</dd>
<dt><strong>dmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum distance from ‘compound’ to look for Particles</p>
</dd>
<dt><strong>max_particles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=20</span></dt>
<dd><p class="first last">Maximum number of Particles to return</p>
</dd>
<dt><strong>particle_kdtree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.PeriodicCKDTree, optional</span></dt>
<dd><p class="first last">KD-tree for looking up nearest neighbors. If not provided, a KD-
tree will be generated from all Particles in self</p>
</dd>
<dt><strong>particle_array</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=mb.Compound, optional</span></dt>
<dd><p class="first last">Array of possible particles to consider for return. If not
provided, this defaults to all Particles in self</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>np.ndarray, shape=(n,), dtype=mb.Compound</strong></dt>
<dd><p class="first last">Particles in range of compound according to user-defined limits</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">periodic_kdtree.PerioidicCKDTree</span></code></dt>
<dd>mBuild implementation of kd-trees</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.spatial.ckdtree</span></code></dt>
<dd>Further details on kd-trees</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.referenced_ports">
<code class="descname">referenced_ports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.referenced_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all Ports referenced by this Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>list of mb.Compound</strong></dt>
<dd><p class="first last">A list of all ports referenced by the Compound</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>objs_to_remove</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove children from the Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>objs_to_remove</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list of mb.Compound</span></dt>
<dd><p class="first last">The Compound(s) to be removed from self</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.remove_bond">
<code class="descname">remove_bond</code><span class="sig-paren">(</span><em>particle_pair</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.remove_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a bond between a pair of Particles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>particle_pair</strong> <span class="classifier-delimiter">:</span> <span class="classifier">indexable object, length=2, dtype=mb.Compound</span></dt>
<dd><p class="first last">The pair of Particles to remove the bond between</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.rigid_particles">
<code class="descname">rigid_particles</code><span class="sig-paren">(</span><em>rigid_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.rigid_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all particles in rigid bodies.</p>
<p>If a rigid_id is specified, then this function will only yield particles
with a matching rigid_id.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rigid_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Include only particles with this rigid body ID</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next particle with a rigid_id that is not None, or the next
particle with a matching rigid_id if specified</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.root">
<code class="descname">root</code><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.root" title="Permalink to this definition">¶</a></dt>
<dd><p>The Compound at the top of self’s hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The Compound at the top of self’s hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>theta</em>, <em>around</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate Compound around an arbitrary vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The angle by which to rotate the Compound, in radians.</p>
</dd>
<dt><strong>around</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">The vector about which to rotate the Compound.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>show_ports=False</em>, <em>forcefield_name=None</em>, <em>forcefield_files=None</em>, <em>forcefield_debug=False</em>, <em>box=None</em>, <em>overwrite=False</em>, <em>residues=None</em>, <em>references_file=None</em>, <em>combining_rule='lorentz'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the Compound to a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Filesystem path in which to save the trajectory. The extension or
prefix will be parsed and control the format. Supported
extensions are: ‘hoomdxml’, ‘gsd’, ‘gro’, ‘top’, ‘lammps’, ‘lmp’</p>
</dd>
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Save ports contained within the compound.</p>
</dd>
<dt><strong>forcefield_files</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Apply a forcefield to the output file using a forcefield provided
by the <cite>foyer</cite> package.</p>
</dd>
<dt><strong>forcefield_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Apply a named forcefield to the output file using the <cite>foyer</cite>
package, e.g. ‘oplsaa’. Forcefields listed here:
<a class="reference external" href="https://github.com/mosdef-hub/foyer/tree/master/foyer/forcefields">https://github.com/mosdef-hub/foyer/tree/master/foyer/forcefields</a></p>
</dd>
<dt><strong>forcefield_debug</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Choose level of verbosity when applying a forcefield through <cite>foyer</cite>.
Specifically, when missing atom types in the forcefield xml file,
determine if the warning is condensed or verbose.</p>
</dd>
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be written to the output file. If ‘None’, a
bounding box is used with 0.25nm buffers at each face to avoid
overlapping atoms.</p>
</dd>
<dt><strong>overwrite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Overwrite if the filename already exists</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>references_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=None</span></dt>
<dd><p class="first last">Specify a filename to write references for the forcefield that is
to be applied. References are written in BiBTeX format.</p>
</dd>
<dt><strong>combining_rule</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’lorentz’</span></dt>
<dd><p class="first last">Specify the combining rule for nonbonded interactions. Only relevant
when the <cite>foyer</cite> package is used to apply a forcefield. Valid
options are ‘lorentz’ and ‘geometric’, specifying Lorentz-Berthelot
and geometric combining rules respectively.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>ref_distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting distance values to reduced units.</p>
</dd>
<dt><strong>ref_energy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting energy values to reduced units.</p>
</dd>
<dt><strong>ref_mass</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1.0</span></dt>
<dd><p class="first last">Normalization factor used when saving to .gsd and .hoomdxml formats
for converting mass values to reduced units.</p>
</dd>
<dt><strong>atom_style: str, default=’full’</strong></dt>
<dd><p class="first last">Defines the style of atoms to be saved in a LAMMPS data file. The following atom
styles are currently supported: ‘full’, ‘atomic’, ‘charge’, ‘molecular’
see <a class="reference external" href="http://lammps.sandia.gov/doc/atom_style.html">http://lammps.sandia.gov/doc/atom_style.html</a> for more
information on atom styles.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.gsdwrite.write_gsd</span></code></dt>
<dd>Write to GSD format</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.hoomdxml.write_hoomdxml</span></code></dt>
<dd>Write to Hoomd XML format</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">formats.lammpsdata.write_lammpsdata</span></code></dt>
<dd>Write to LAMMPS data format</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.spin">
<code class="descname">spin</code><span class="sig-paren">(</span><em>theta</em>, <em>around</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate Compound in place around an arbitrary vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The angle by which to rotate the Compound, in radians.</p>
</dd>
<dt><strong>around</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd><p class="first last">The axis about which to spin the Compound.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.successors">
<code class="descname">successors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield Compounds below self in the hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mb.Compound</strong></dt>
<dd><p class="first last">The next Particle below self in the hierarchy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.to_intermol">
<code class="descname">to_intermol</code><span class="sig-paren">(</span><em>molecule_types=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.to_intermol" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an InterMol system from a Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>molecule_types</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or tuple of subclasses of Compound</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>intermol_system</strong> <span class="classifier-delimiter">:</span> <span class="classifier">intermol.system.System</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.to_parmed">
<code class="descname">to_parmed</code><span class="sig-paren">(</span><em>box=None</em>, <em>title=''</em>, <em>residues=None</em>, <em>show_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.to_parmed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a ParmEd Structure from a Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be used when converting to a <cite>Structure</cite>.
If ‘None’, a bounding box is used with 0.25nm buffers at
each face to avoid overlapping atoms, unless <cite>self.periodicity</cite>
is not None, in which case those values are used for the
box lengths.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=self.name</span></dt>
<dd><p class="first last">Title/name of the ParmEd Structure</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional, default=False</span></dt>
<dd><p class="first last">Include all port atoms when converting to a <cite>Structure</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>parmed.structure.Structure</strong></dt>
<dd><p class="first last">ParmEd Structure object converted from self</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">parmed.structure.Structure</span></code></dt>
<dd>Details on the ParmEd Structure object</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.to_trajectory">
<code class="descname">to_trajectory</code><span class="sig-paren">(</span><em>show_ports=False</em>, <em>chains=None</em>, <em>residues=None</em>, <em>box=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.to_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to an md.Trajectory and flatten the compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Include all port atoms when converting to trajectory.</p>
</dd>
<dt><strong>chains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list of mb.Compound</span></dt>
<dd><p class="first last">Chain types to add to the topology</p>
</dd>
<dt><strong>residues</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str of list of str</span></dt>
<dd><p class="first last">Labels of residues in the Compound. Residues are assigned by
checking against Compound.name.</p>
</dd>
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box, optional, default=self.boundingbox (with buffer)</span></dt>
<dd><p class="first last">Box information to be used when converting to a <cite>Trajectory</cite>.
If ‘None’, a bounding box is used with a 0.5nm buffer in each
dimension. to avoid overlapping atoms, unless <cite>self.periodicity</cite>
is not None, in which case those values are used for the
box lengths.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trajectory</strong> <span class="classifier-delimiter">:</span> <span class="classifier">md.Trajectory</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_to_topology</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>by</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the Compound by a vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(3,), dtype=float</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.translate_to">
<code class="descname">translate_to</code><span class="sig-paren">(</span><em>pos</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.translate_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the Compound to a specific position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=3(,), dtype=float</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.unlabel_rigid_bodies">
<code class="descname">unlabel_rigid_bodies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.unlabel_rigid_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all rigid body labels from the Compound</p>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.update_coordinates">
<code class="descname">update_coordinates</code><span class="sig-paren">(</span><em>filename</em>, <em>update_port_locations=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.update_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the coordinates of this Compound from a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of file from which to load coordinates. Supported file types
are the same as those supported by load()</p>
</dd>
<dt><strong>update_port_locations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Update the locations of Ports so that they are shifted along with
their anchor particles.  Note: This conserves the location of
Ports with respect to the anchor Particle, but does not conserve
the orientation of Ports with respect to the molecule as a whole.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">load</span></code></dt>
<dd>Load coordinates from a file</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.visualize">
<code class="descname">visualize</code><span class="sig-paren">(</span><em>show_ports=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.visualize" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the Compound using nglview.</p>
<p>Allows for visualization of a Compound within a Jupyter Notebook.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>show_ports</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=False</span></dt>
<dd><p class="first last">Visualize Ports in addition to Particles</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.xyz">
<code class="descname">xyz</code><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all particle coordinates in this compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 3), dtype=float</span></dt>
<dd><p class="first last">Array with the positions of all particles.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mbuild.recipes.silica_interface.SilicaInterface.xyz_with_ports">
<code class="descname">xyz_with_ports</code><a class="headerlink" href="#mbuild.recipes.silica_interface.SilicaInterface.xyz_with_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all particle coordinates in this compound including ports.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 3), dtype=float</span></dt>
<dd><p class="first last">Array with the positions of all particles and ports.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lattice">
<h2>Lattice<a class="headerlink" href="#lattice" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="mbuild.lattice.Lattice">
<em class="property">class </em><code class="descclassname">mbuild.lattice.</code><code class="descname">Lattice</code><span class="sig-paren">(</span><em>lattice_spacing=None</em>, <em>lattice_vectors=None</em>, <em>lattice_points=None</em>, <em>angles=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mbuild/lattice.html#Lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mbuild.lattice.Lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Develop crystal structure from user defined inputs.</p>
<p>Lattice, the abstract building block of a crystal cell.
Once defined by the user, the lattice can then be populated with
Compounds and replicated as many cell lengths desired in 3D space.</p>
<p>A Lattice is defined through the Bravais lattice definitions. With edge
vectors a1, a2, a3; lattice spacing a,b,c; and lattice points at unique
fractional positions between 0-1 in 3 dimensions. This encapsulates
distance, area, volume, depending on the parameters defined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>lattice_spacing</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape=(3,), required, dtype=float</span></dt>
<dd><p class="first last">Array of lattice spacings a,b,c for the cell.</p>
</dd>
<dt><strong>lattice_vectors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape=(3, 3), optional</span></dt>
<dd><blockquote class="first">
<div><p>default=[[1,0,0], [0,1,0], [0,0,1]]</p>
</div></blockquote>
<p class="last">Vectors that encase the unit cell corresponding to dimension. Will
only default to these values if no angles were defined as well.</p>
</dd>
<dt><strong>lattice_points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary, shape={‘id’: [[nested list of positions]]</span></dt>
<dd><p class="first last">optional, default={‘default’: [[0.,0.,0.]]}
Locations of all lattice points in cell using fractional coordinates.</p>
</dd>
<dt><strong>angles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape=(3,), optional, dtype=float</span></dt>
<dd><p class="first last">Array of inter-planar Bravais angles in degrees.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Generating a triclinic lattice for cholesterol.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mbuild.utils.io</span> <span class="k">import</span> <span class="n">get_fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># reading in the lattice parameters for crystalline cholesterol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angle_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">94.64</span><span class="p">,</span> <span class="mf">90.67</span><span class="p">,</span> <span class="mf">96.32</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.4172</span><span class="p">,</span> <span class="mf">3.4209</span><span class="p">,</span> <span class="mf">1.0481</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cholesterol&#39;</span><span class="p">:[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholesterol_lattice</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">Lattice</span><span class="p">(</span><span class="n">spacing</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">angles</span><span class="o">=</span><span class="n">angle_values</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">lattice_points</span><span class="o">=</span><span class="n">basis</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The lattice based on the bravais lattice parameters of crystalline</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># cholesterol was generated.</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Replicating the triclinic unit cell out 3 replications</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># in x,y,z directions.</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cholesterol_unit</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">Compound</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholesterol_unit</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">get_fn</span><span class="p">(</span><span class="s1">&#39;cholesterol.pdb&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># associate basis vector with id &#39;cholesterol&#39; to cholesterol Compound</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis_dictionary</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cholesterol&#39;</span> <span class="p">:</span> <span class="n">cholesterol_unit</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expanded_cell</span> <span class="o">=</span> <span class="n">cholesterol_lattice</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                             <span class="n">compound_dict</span><span class="o">=</span><span class="n">basis_dictionary</span><span class="p">)</span>
</pre></div>
</div>
<p>The unit cell of cholesterol was associated with a Compound that contains
the connectivity data and spatial arrangements of a cholesterol molecule.
The unit cell was then expanded out in x,y,z directions and cholesterol
Compounds were populated.</p>
<p>Generating BCC CsCl crystal structure</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chlorine</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">Compound</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Cl&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># angles not needed, when not provided, defaults to 90,90,90</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cesium</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">Compound</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Cs&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spacing</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">4123</span><span class="p">,</span> <span class="o">.</span><span class="mi">4123</span><span class="p">,</span> <span class="o">.</span><span class="mi">4123</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Cl&#39;</span> <span class="p">:</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]],</span> <span class="s1">&#39;Cs&#39;</span> <span class="p">:</span> <span class="p">[[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">]]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cscl_lattice</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">Lattice</span><span class="p">(</span><span class="n">spacing</span><span class="p">,</span> <span class="n">lattice_points</span><span class="o">=</span><span class="n">basis</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Now associate id with Compounds for lattice points and replicate 3x</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cscl_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Cl&#39;</span> <span class="p">:</span> <span class="n">chlorine</span><span class="p">,</span> <span class="s1">&#39;Cs&#39;</span> <span class="p">:</span> <span class="n">cesium</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cscl_compound</span> <span class="o">=</span> <span class="n">cscl_lattice</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">compound_dict</span><span class="o">=</span><span class="n">cscl_dict</span><span class="p">)</span>
</pre></div>
</div>
<p>A multi-Compound basis was created and replicated. For each unique basis
atom position, a separate entry must be completed for the basis_atom
input.</p>
<p>Generating FCC Copper cell with lattice_vectors instead of angles</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">copper</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">Compound</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Cu&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lattice_vector</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spacing</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">36149</span><span class="p">,</span> <span class="o">.</span><span class="mi">36149</span><span class="p">,</span> <span class="o">.</span><span class="mi">36149</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">copper_locations</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Cu&#39;</span> <span class="p">:</span> <span class="n">copper_locations</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">copper_lattice</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">Lattice</span><span class="p">(</span><span class="n">lattice_spacing</span> <span class="o">=</span> <span class="n">spacing</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">lattice_vectors</span><span class="o">=</span><span class="n">lattice_vector</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">lattice_points</span><span class="o">=</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">copper_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Cu&#39;</span> <span class="p">:</span> <span class="n">copper</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">copper_pillar</span> <span class="o">=</span> <span class="n">copper_lattice</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">compound_dict</span><span class="o">=</span><span class="n">copper_dict</span><span class="p">)</span>
</pre></div>
</div>
<p>Generating the 2d Structure Graphene carbon backbone</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mbuild</span> <span class="k">as</span> <span class="nn">mb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">carbon</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">Compound</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">120</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">carbon_locations</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span> <span class="p">:</span> <span class="n">carbon_locations</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graphene</span> <span class="o">=</span> <span class="n">mb</span><span class="o">.</span><span class="n">Lattice</span><span class="p">(</span><span class="n">lattice_spacing</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">2456</span><span class="p">,</span> <span class="o">.</span><span class="mi">2456</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="n">angles</span><span class="o">=</span><span class="n">angles</span><span class="p">,</span> <span class="n">lattice_points</span><span class="o">=</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">carbon_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span> <span class="p">:</span> <span class="n">carbon</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graphene_cell</span> <span class="o">=</span> <span class="n">graphene</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="n">compound_dict</span><span class="o">=</span><span class="n">carbon_dict</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dimension</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, 3</span></dt>
<dd><p class="first last">Default dimensionality within mBuild. If choosing a lower dimension,
pad the relevant arrays with zeroes.</p>
</dd>
<dt><strong>lattice_spacing</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array, shape=(3,), required, dtype=float</span></dt>
<dd><p class="first last">Array of lattice spacings a,b,c for the cell.</p>
</dd>
<dt><strong>lattice_vectors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array, shape=(3, 3), optional</span></dt>
<dd><blockquote class="first">
<div><p>default=[[1,0,0], [0,1,0], [0,0,1]]</p>
</div></blockquote>
<p class="last">Vectors that encase the unit cell corresponding to dimension. Will
only default to these values if no angles were defined as well.</p>
</dd>
<dt><strong>lattice_points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary, shape={‘id’: [[nested list of positions]]</span></dt>
<dd><p class="first last">optional, default={‘default’: [[0.,0.,0.]]}
Locations of all lattice points in cell using fractional coordinates.</p>
</dd>
<dt><strong>angles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array, shape=(3,), optional, dtype=float</span></dt>
<dd><p class="first last">Array of inter-planar Bravais angles</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mbuild.lattice.Lattice.populate">
<code class="descname">populate</code><span class="sig-paren">(</span><em>compound_dict=None</em>, <em>x=1</em>, <em>y=1</em>, <em>z=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mbuild/lattice.html#Lattice.populate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mbuild.lattice.Lattice.populate" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand lattice and create compound from lattice.</p>
<p>populate will expand lattice based on user input. The user must also
pass in a dictionary that contains the keys that exist in the
basis_dict. The corresponding Compound will be the full lattice
returned to the user.</p>
<p>If no dictionary is passed to the user, Dummy Compounds will be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1</span></dt>
<dd><p class="first last">How many iterations in the x direction.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1</span></dt>
<dd><p class="first last">How many iterations in the y direction.</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1</span></dt>
<dd><p class="first last">How many iterations in the z direction.</p>
</dd>
<dt><strong>compound_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary, optional, default=None</span></dt>
<dd><p class="first last">Link between basis_dict and Compounds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-mbuild.packing">
<span id="packing"></span><h2>Packing<a class="headerlink" href="#module-mbuild.packing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="mbuild.packing.fill_box">
<code class="descclassname">mbuild.packing.</code><code class="descname">fill_box</code><span class="sig-paren">(</span><em>compound</em>, <em>n_compounds=None</em>, <em>box=None</em>, <em>density=None</em>, <em>overlap=0.2</em>, <em>seed=12345</em>, <em>edge=0.2</em>, <em>compound_ratio=None</em>, <em>aspect_ratio=None</em>, <em>fix_orientation=False</em>, <em>temp_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mbuild/packing.html#fill_box"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mbuild.packing.fill_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a box with a compound using packmol.</p>
<p>Two arguments of <cite>n_compounds, box, and density</cite> must be specified.</p>
<p>If <cite>n_compounds</cite> and <cite>box</cite> are not None, the specified number of
n_compounds will be inserted into a box of the specified size.</p>
<p>If <cite>n_compounds</cite> and <cite>density</cite> are not None, the corresponding box
size will be calculated internally. In this case, <cite>n_compounds</cite>
must be an int and not a list of int.</p>
<p>If <cite>box</cite> and <cite>density</cite> are not None, the corresponding number of
compounds will be calculated internally.</p>
<p>For the cases in which <cite>box</cite> is not specified but generated internally,
the default behavior is to calculate a cubic box. Optionally,
<cite>aspect_ratio</cite> can be passed to generate a non-cubic box.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>compound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list of mb.Compound</span></dt>
<dd><p class="first last">Compound or list of compounds to be put in box.</p>
</dd>
<dt><strong>n_compounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or list of int</span></dt>
<dd><p class="first last">Number of compounds to be put in box.</p>
</dd>
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box</span></dt>
<dd><p class="first last">Box to be filled by compounds.</p>
</dd>
<dt><strong>density</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, units kg/m^3, default=None</span></dt>
<dd><p class="first last">Target density for the system in macroscale units. If not None, one of
<cite>n_compounds</cite> or <cite>box</cite>, but not both, must be specified.</p>
</dd>
<dt><strong>overlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, units nm, default=0.2</span></dt>
<dd><p class="first last">Minimum separation between atoms of different molecules.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default=12345</span></dt>
<dd><p class="first last">Random seed to be passed to PACKMOL.</p>
</dd>
<dt><strong>edge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, units nm, default=0.2</span></dt>
<dd><p class="first last">Buffer at the edge of the box to not place molecules. This is necessary
in some systems because PACKMOL does not account for periodic boundary
conditions in its optimization.</p>
</dd>
<dt><strong>compound_ratio</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, default=None</span></dt>
<dd><p class="first last">Ratio of number of each compound to be put in box. Only used in the
case of <cite>density</cite> and <cite>box</cite> having been specified, <cite>n_compounds</cite> not
specified, and more than one <cite>compound</cite>.</p>
</dd>
<dt><strong>aspect_ratio</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of float</span></dt>
<dd><p class="first last">If a non-cubic box is desired, the ratio of box lengths in the x, y,
and z directions.</p>
</dd>
<dt><strong>fix_orientation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool or list of bools</span></dt>
<dd><p class="first last">Specify that compounds should not be rotated when filling the box,
default=False.</p>
</dd>
<dt><strong>temp_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, default=None</span></dt>
<dd><p class="first last">File name to write PACKMOL’s raw output to.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filled</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mbuild.packing.fill_region">
<code class="descclassname">mbuild.packing.</code><code class="descname">fill_region</code><span class="sig-paren">(</span><em>compound</em>, <em>n_compounds</em>, <em>region</em>, <em>overlap=0.2</em>, <em>seed=12345</em>, <em>edge=0.2</em>, <em>fix_orientation=False</em>, <em>temp_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mbuild/packing.html#fill_region"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mbuild.packing.fill_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a region of a box with a compound using packmol.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>compound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound or list of mb.Compound</span></dt>
<dd><p class="first last">Compound or list of compounds to be put in region.</p>
</dd>
<dt><strong>n_compounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or list of int</span></dt>
<dd><p class="first last">Number of compounds to be put in region.</p>
</dd>
<dt><strong>region</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box or list of mb.Box</span></dt>
<dd><p class="first last">Region to be filled by compounds.</p>
</dd>
<dt><strong>overlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, units nm, default=0.2</span></dt>
<dd><p class="first last">Minimum separation between atoms of different molecules.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default=12345</span></dt>
<dd><p class="first last">Random seed to be passed to PACKMOL.</p>
</dd>
<dt><strong>edge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, units nm, default=0.2</span></dt>
<dd><p class="first last">Buffer at the edge of the region to not place molecules. This is
necessary in some systems because PACKMOL does not account for
periodic boundary conditions in its optimization.</p>
</dd>
<dt><strong>fix_orientation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool or list of bools</span></dt>
<dd><p class="first last">Specify that compounds should not be rotated when filling the box,
default=False.</p>
</dd>
<dt><strong>temp_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, default=None</span></dt>
<dd><p class="first last">File name to write PACKMOL’s raw output to.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filled</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd></dd>
<dt><strong>If using mulitple regions and compounds, the nth value in each list are used in order.</strong></dt>
<dd></dd>
<dt><strong>For example, if the third compound will be put in the third region using the third value in n_compounds.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mbuild.packing.solvate">
<code class="descclassname">mbuild.packing.</code><code class="descname">solvate</code><span class="sig-paren">(</span><em>solute</em>, <em>solvent</em>, <em>n_solvent</em>, <em>box</em>, <em>overlap=0.2</em>, <em>seed=12345</em>, <em>edge=0.2</em>, <em>fix_orientation=False</em>, <em>temp_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mbuild/packing.html#solvate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mbuild.packing.solvate" title="Permalink to this definition">¶</a></dt>
<dd><p>Solvate a compound in a box of solvent using packmol.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>solute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd><p class="first last">Compound to be placed in a box and solvated.</p>
</dd>
<dt><strong>solvent</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd><p class="first last">Compound to solvate the box.</p>
</dd>
<dt><strong>n_solvent</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of solvents to be put in box.</p>
</dd>
<dt><strong>box</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Box</span></dt>
<dd><p class="first last">Box to be filled by compounds.</p>
</dd>
<dt><strong>overlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, units nm, default=0.2</span></dt>
<dd><p class="first last">Minimum separation between atoms of different molecules.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default=12345</span></dt>
<dd><p class="first last">Random seed to be passed to PACKMOL.</p>
</dd>
<dt><strong>edge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, units nm, default=0.2</span></dt>
<dd><p class="first last">Buffer at the edge of the box to not place molecules. This is necessary
in some systems because PACKMOL does not account for periodic boundary
conditions in its optimization.</p>
</dd>
<dt><strong>fix_orientation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Specify if solvent should not be rotated when filling box,
default=False.</p>
</dd>
<dt><strong>temp_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, default=None</span></dt>
<dd><p class="first last">File name to write PACKMOL’s raw output to.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>solvated</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mbuild.pattern">
<span id="pattern"></span><h2>Pattern<a class="headerlink" href="#module-mbuild.pattern" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="mbuild.pattern.DiskPattern">
<em class="property">class </em><code class="descclassname">mbuild.pattern.</code><code class="descname">DiskPattern</code><span class="sig-paren">(</span><em>n</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mbuild/pattern.html#DiskPattern"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mbuild.pattern.DiskPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate N evenly distributed points on the unit circle along z = 0.</p>
<p>Disk is centered at the origin. Algorithm based on Vogel’s method.</p>
<p>Code by Alexandre Devert:
<a class="reference external" href="http://blog.marmakoide.org/?p=1">http://blog.marmakoide.org/?p=1</a></p>
<dl class="method">
<dt id="mbuild.pattern.DiskPattern.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>compound</em>, <em>orientation=''</em>, <em>compound_port=''</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.pattern.DiskPattern.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Arrange copies of a Compound as specified by the Pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>compound</strong></dt>
<dd></dd>
<dt><strong>orientation</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.pattern.DiskPattern.apply_to_compound">
<code class="descname">apply_to_compound</code><span class="sig-paren">(</span><em>guest</em>, <em>guest_port_name='down'</em>, <em>host=None</em>, <em>backfill=None</em>, <em>backfill_port_name='up'</em>, <em>scale=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.pattern.DiskPattern.apply_to_compound" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach copies of a guest Compound to Ports on a host Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>guest</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd><p class="first last">The Compound prototype to be applied to the host Compound</p>
</dd>
<dt><strong>guest_port_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’down’</span></dt>
<dd><p class="first last">The name of the port located on <cite>guest</cite> to attach to the host</p>
</dd>
<dt><strong>host</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound, optional, default=None</span></dt>
<dd><p class="first last">A Compound with available ports to add copies of <cite>guest</cite> to</p>
</dd>
<dt><strong>backfill</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound, optional, default=None</span></dt>
<dd><p class="first last">A Compound to add to the remaining available ports on <cite>host</cite>
after clones of <cite>guest</cite> have been added for each point in the
pattern</p>
</dd>
<dt><strong>backfill_port_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’up’</span></dt>
<dd><p class="first last">The name of the port located on <cite>backfill</cite> to attach to the host</p>
</dd>
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Scale the points in the pattern to the lengths of the <cite>host</cite>’s
<cite>boundingbox</cite> and shift them by the <cite>boundingbox</cite>’s mins</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.pattern.DiskPattern.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>by</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.pattern.DiskPattern.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale the points in the Pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or np.ndarray, shape=(3,)</span></dt>
<dd><p class="first last">The factor to scale by. If a scalar, scale all directions isotropically.
If np.ndarray, scale each direction independently.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mbuild.pattern.SpherePattern">
<em class="property">class </em><code class="descclassname">mbuild.pattern.</code><code class="descname">SpherePattern</code><span class="sig-paren">(</span><em>n</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mbuild/pattern.html#SpherePattern"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mbuild.pattern.SpherePattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate N evenly distributed points on the unit sphere.</p>
<p>Sphere is centered at the origin. Alrgorithm based on the ‘Golden Spiral’.</p>
<p>Code by Chris Colbert from the numpy-discussion list:
<a class="reference external" href="http://mail.scipy.org/pipermail/numpy-discussion/2009-July/043811.html">http://mail.scipy.org/pipermail/numpy-discussion/2009-July/043811.html</a></p>
<dl class="method">
<dt id="mbuild.pattern.SpherePattern.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>compound</em>, <em>orientation=''</em>, <em>compound_port=''</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.pattern.SpherePattern.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Arrange copies of a Compound as specified by the Pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>compound</strong></dt>
<dd></dd>
<dt><strong>orientation</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.pattern.SpherePattern.apply_to_compound">
<code class="descname">apply_to_compound</code><span class="sig-paren">(</span><em>guest</em>, <em>guest_port_name='down'</em>, <em>host=None</em>, <em>backfill=None</em>, <em>backfill_port_name='up'</em>, <em>scale=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.pattern.SpherePattern.apply_to_compound" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach copies of a guest Compound to Ports on a host Compound.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>guest</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound</span></dt>
<dd><p class="first last">The Compound prototype to be applied to the host Compound</p>
</dd>
<dt><strong>guest_port_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’down’</span></dt>
<dd><p class="first last">The name of the port located on <cite>guest</cite> to attach to the host</p>
</dd>
<dt><strong>host</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound, optional, default=None</span></dt>
<dd><p class="first last">A Compound with available ports to add copies of <cite>guest</cite> to</p>
</dd>
<dt><strong>backfill</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mb.Compound, optional, default=None</span></dt>
<dd><p class="first last">A Compound to add to the remaining available ports on <cite>host</cite>
after clones of <cite>guest</cite> have been added for each point in the
pattern</p>
</dd>
<dt><strong>backfill_port_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default=’up’</span></dt>
<dd><p class="first last">The name of the port located on <cite>backfill</cite> to attach to the host</p>
</dd>
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default=True</span></dt>
<dd><p class="first last">Scale the points in the pattern to the lengths of the <cite>host</cite>’s
<cite>boundingbox</cite> and shift them by the <cite>boundingbox</cite>’s mins</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mbuild.pattern.SpherePattern.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>by</em><span class="sig-paren">)</span><a class="headerlink" href="#mbuild.pattern.SpherePattern.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale the points in the Pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or np.ndarray, shape=(3,)</span></dt>
<dd><p class="first last">The factor to scale by. If a scalar, scale all directions isotropically.
If np.ndarray, scale each direction independently.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="citing_mbuild.html" class="btn btn-neutral float-right" title="Citing mBuild" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="coordinate_transforms.html" class="btn btn-neutral" title="Coordinate transformations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2017, Vanderbilt University

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>